{"version":3,"sources":["Log.js","WorkerPool.js","registerServiceWorker.js","Video.js","Timecode.js","RangeSlider.js","TimeSlider.js","Draw.js","Transform.js","Dropzone.js","Icon.js","Playback.js","App.js","index.js"],"names":["Logger","namespace","Object","_home_travis_build_McManning_drawover_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__","this","print","debug","apply","concat","Array","prototype","slice","call","arguments","log","WorkerPool","props","_this","_home_travis_build_McManning_drawover_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__","_home_travis_build_McManning_drawover_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__","state","totalReady","workers","waitingToPostInfo","metadata","info","module","startWebWorkers","prevProps","length","addWebWorker","_this2","worker","Worker","WEBWORKER_SCRIPT","ready","working","onmessage","e","onWorkerMessage","onerror","onWorkerError","push","file","filename","name","reader","FileReader","onload","_this3","forEach","postMessage","type","data","result","readAsArrayBuffer","event","message","onWorkerReady","onWorkerLoaded","onWorkerInfo","onWorkerFrames","error","count","setState","onMetadata","onFrames","start","end","frames","idle","i","frame","distance","skip","iframe","parseInt","getIdleWorkers","warning","workPerThread","Math","floor","console","React","Component","defaultProps","isLocalhost","Boolean","window","location","hostname","match","registerValidSW","swUrl","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","controller","catch","Video","classCallCheck","possibleConstructorReturn","getPrototypeOf","onVideoLoad","bind","assertThisInitialized","onVideoSeeked","onAnimFrame","onImageLoad","video","createRef","canvas","backbuffer","image","context","backbufferContext","total","frameCache","cacheFrameReady","videoFrameReady","current","addEventListener","transform","translate","scale","rotate","prevState","x","y","totalFrames","duration","fps","videoWidth","videoHeight","width","backbufferScale","height","previousFrameTime","Date","now","previousFrame","clearCanvas","drawCurrentFrame","onReady","canPlayType","src","play","requestId","requestAnimationFrame","pause","cancelAnimationFrame","paused","ended","delta","interval","startFrame","endFrame","ctx","getContext","setTransform","save","clearRect","restore","drawImage","onFrame","len","min","keys","undefined","max","sourcesDisplay","showSources","react_default","a","createElement","className","ref","style","display","muted","loop","alt","value","round","currentTime","val","clampFrame","isFrameCached","playbackRate","Timecode","seconds","minutes","hours","timecode","_timecode$split","split","_timecode$split2","slicedToArray","RangeSlider","onUpdateSlider","onChangeStartFrame","onChangeEndFrame","onChange","noUiSlider","create","connect","behaviour","tooltips","getTooltipFormatter","animate","range","margin","step","slider","connector","target","getElementsByClassName","lowerHandle","upperHandle","on","el","noop","updateOptions","getBoundingClientRect","classList","remove","add","values","updateHandleLabels","defineProperty","set","readOnly","onBlur","stopPropagation","TimeSlider","currentInput","onSliderChange","onInputChange","onInputBlur","onClick","pips","getPips","handle","get","updateHandleVisibility","updateHandleWidth","_this$state","factor","mode","density","ival","_this$state2","map","key","left","data-type","data-frame","dataset","renderKeys","Draw","penColors","tool","color","lineWidth","previousTool","history","historyIndex","empty","points","dragging","mouseX","mouseY","matrix","DOMMatrixReadOnly","temp","onMouseMove","onMouseUp","onMouseDown","onTouchStart","onTouchEnd","onTouchMove","onTouchCancel","onKeyDown","onChangeLineWidth","onClear","onContextMenu","undo","redo","readonly","setPen","source","deserialize","redrawCursorSVG","isEmpty","tempContext","canvasContext","pushHistory","globalCompositeOperation","clearTemp","onDraw","toolsVisible","buttons","trackMouse","draw","endCurrentLine","touches","changedTouches","touchIdentifier","identifier","trackTouch","keyCode","ctrlKey","preventDefault","toolsOrigin","top","pageY","pageX","point","transformedPoint","nativeEvent","offsetX","offsetY","touch","offsetLeft","offsetTop","clear","ERASE_TOOL","pen","PEN_TOOL","CLEAR_TOOL","operation","cpx","cpy","lineJoin","lineCap","strokeStyle","fillStyle","beginPath","arc","PI","fill","closePath","moveTo","quadraticCurveTo","stroke","tempCtx","splice","redraw","lastTool","buffer","substr","p","Int16Array","int16","deserialized","toString","padStart","plen","size","rad","svg","padding","cursor","encodeURI","canvasCtx","inv","inverse","DOMPoint","c","b","d","f","idx","backgroundColor","setEraser","opacity","tabIndex","onMouseLeave","renderTools","Transform","active","onMouseDownCapture","onMouseMoveCapture","onWheelCapture","onKeyDownCapture","onKeyUpCapture","invScale","movementX","movementY","deltaY","deltaX","sign","pow","localSpace","zoom","Error","children","Children","child","cloneElement","Dropzone","onDragEnter","onDragLeave","onDrop","dataTransfer","items","kind","getAsFile","files","onFile","onDragOver","Icon","other","objectWithoutProperties","assign","Playback","onClickPlay","onClickPause","onSelectSpeed","onPlay","onPause","onSpeed","parseFloat","offset","onSkip","speed","src_Icon","Number","MAX_SAFE_INTEGER","playing","App","isNewSession","loading","videoFilename","videoSourceUrl","totalWebWorkers","drawCache","time","onVideoReady","onPickRange","onPickFrame","onDropFile","onPlaybackSpeed","onPlaybackPlay","onPlaybackPause","onPlaybackSkip","onDrawDraw","onDrawClear","onWorkerMetadata","onAddWebWorker","onFrameCache","updateCanvasDimensions","clientWidth","clientHeight","cacheFrames","hasKey","setKey","changeDrawover","setFrame","setRange","canLoad","changeVideoSource","alert","extractFrames","deleteKey","prevFrame","serialize","reset","updateGhosting","url","File","URL","createObjectURL","deleteAllKeys","load","adjacent","getPreviousDrawFrame","ghostLayers","refs","components","ghostOpacityScale","src_Draw_0","src_Dropzone_0","src_Transform","src_Video_0","renderDrawovers","src_TimeSlider_0","src_Playback_0","src_RangeSlider_0","ReactDOM","render","src_App_0","document","getElementById","process","origin","fetch","response","status","headers","indexOf","unregister","reload","checkValidServiceWorker","registerServiceWorker"],"mappings":"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","file":"static/js/main.31c85680.chunk.js","sourcesContent":["\nimport debug from 'debug';\n\n/**\n * Wrapper for debug.js to handle different log message levels\n */\nclass Logger {\n    constructor(namespace) {\n        this.print = debug('drawover:' + namespace);\n    }\n\n    debug() {\n        this.print('%c debug ', 'background-color: #aaaaaa; color: #ffffff', ...arguments);\n    }\n\n    info() {\n        this.print('%c info ', 'background-color: #66c2cd; color: #ffffff', ...arguments);\n    }\n\n    warning() {\n        this.print('%c warning ', 'background-color: #dbaa79; color: #ffffff', ...arguments);\n    }\n\n    error() {\n        this.print('%c error ', 'background-color: #e88388; color: #ffffff', ...arguments);\n    }\n}\n\nexport default Logger;\n","\nimport React from 'react';\n\nimport Logger from './Log';\nconst log = new Logger('WorkerPool');\n\n/**\n * WorkerPool manages a collection of WebWorkers for background data processing.\n *\n * <WorkerPool workers={Number} onMetadata={callable} onFrames={callable} />\n *\n * `onMetadata` is called after a new source file is loaded via `load` with\n * metadata about the source file (fps, encoding, etc). Argument is an object\n * that contains keys width, height, fps, tbr\n *\n * `onFrames` is called once a worker has generated one or more frame images\n * TODO: Arguments?\n */\nclass WorkerPool extends React.Component {\n    static WEBWORKER_SCRIPT = 'ffmpeg-worker.js';\n\n    constructor(props) {\n        super(props);\n\n        // In state for debug write\n        this.state = {\n            totalReady: 0\n        };\n\n        this.workers = [];\n        this.waitingToPostInfo = false;\n        this.metadata = {};\n\n        log.info('hello', module);\n    }\n\n    componentDidMount() {\n        this.startWebWorkers();\n    }\n\n    componentDidUpdate(prevProps) {\n        if (prevProps.workers !== this.props.workers) {\n            this.startWebWorkers();\n        }\n    }\n\n    /**\n     * Spin up web worker threads up to `props.workers` size.\n     *\n     * Note that worker count only goes up, not down.\n     */\n    startWebWorkers() {\n        while (this.workers.length < this.props.workers) {\n            this.addWebWorker();\n        }\n    }\n\n    /**\n     * Add a new Web Worker to our pool\n     */\n    addWebWorker() {\n        const worker = new Worker(WorkerPool.WEBWORKER_SCRIPT);\n        worker.ready = false;\n        worker.working = false;\n\n        worker.onmessage = (e) => this.onWorkerMessage(worker, e);\n        worker.onerror = (e) => this.onWorkerError(worker, e);\n\n        this.workers.push(worker);\n    }\n\n    /**\n     * Provide a new source file to every worker to operate on\n     *\n     * @param {File} file\n     */\n    load(file) {\n        const workers = this.workers;\n        const filename = file.name;\n\n        const reader = new FileReader();\n        reader.onload = function () {\n            workers.forEach((worker) => {\n                worker.postMessage({\n                    type: 'load',\n                    filename: filename,\n                    data: this.result\n                });\n            });\n        };\n\n        reader.readAsArrayBuffer(file);\n\n        // TODO: Better handle workers that are in the middle of work.\n        // Maybe queue this up and wait until all workers are idle.\n\n        this.waitingToPostInfo = true;\n    }\n\n    /**\n     * Message posted from one of the Web Workers\n     *\n     * This will delegate to one of the other onWorker* methods based on message type\n     *\n     * @param {Worker} worker\n     * @param {object} event\n     */\n    onWorkerMessage(worker, event) {\n        const message = event.data;\n        log.info('Web Worker Message', worker, message);\n\n        switch (message.type) {\n            case 'ready':\n                this.onWorkerReady(worker, message);\n                break;\n            case 'loaded':\n                this.onWorkerLoaded(worker, message);\n                break;\n            case 'info':\n                this.onWorkerInfo(worker, message);\n                break;\n            case 'frames':\n                this.onWorkerFrames(worker, message);\n                break;\n            default:\n                log.error('Unknown Web Worker Message', worker, message);\n                break;\n        }\n    }\n\n    /**\n     * Web Worker ran into an error\n     *\n     * @param {Worker} worker\n     */\n    onWorkerError(worker) {\n        log.error('Web Worker Error', arguments);\n    }\n\n    /**\n     * Web Worker is ready to start receiving commands\n     *\n     * @param {Worker} worker\n     */\n    onWorkerReady(worker) {\n        worker.ready = true;\n\n        // Count the number of ready workers at this point\n        let count = 0;\n        this.workers.forEach((worker) => {\n            if (worker.ready) {\n                count++;\n            }\n        });\n\n        this.setState({\n            totalReady: count\n        });\n    }\n\n    /**\n     * Worker fired a 'loaded' event, indicating that a source video is ready\n     *\n     * The first worker to load a source video will try to load additional\n     * information about the source (fps, encoding, etc).\n     *\n     * @param {Worker} worker\n     */\n    onWorkerLoaded(worker) {\n        if (this.waitingToPostInfo) {\n            this.waitingToPostInfo = false;\n            worker.postMessage({\n                type: 'info'\n            });\n        }\n    }\n\n    /**\n     * Worker fired an `info` event - notify `onMetadata` listener\n     *\n     * @param {Worker} worker\n     * @param {object} message\n     */\n    onWorkerInfo(worker, message) {\n        this.metadata = message.metadata;\n\n        if (this.props.onMetadata) {\n            this.props.onMetadata(message.metadata);\n        }\n    }\n\n    /**\n     * Worker fired a `frames` event - notify `onFrames` listener\n     *\n     * @param {Worker} worker\n     * @param {object} message\n     */\n    onWorkerFrames(worker, message) {\n        if (this.props.onFrames) {\n            this.props.onFrames(\n                message.start,\n                message.end,\n                message.frames\n            );\n        }\n    }\n\n    /**\n     * Get worker that aren't processing data\n     *\n     * @return {array} of worker instances\n     */\n    getIdleWorkers() {\n        const idle = [];\n\n        this.workers.forEach((worker) => {\n            if (!worker.working && worker.ready) {\n                idle.push(worker);\n            }\n        });\n\n        return idle;\n    }\n\n    /**\n     * Returns true if one or more workers are still not ready\n     * (Happens when the browser is slow to start up new Web Worker threads)\n     *\n     * @return {boolean}\n     */\n    isWarmingUp() {\n        for (let i = 0; i < this.workers.length; i++) {\n            if (!this.workers[i].ready) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Start retrieving frames outward from the given frame\n     *\n     * Will execute `onFrames` with batches of frame images generated by the worker threads\n     *\n     * @param {Number} frame    Frame number to center the caching behavior on\n     *\n     * @param {Number} distance Number of frames in both directions of the given frame to cache.\n     *                          If there are not enough frames in either direction of the given\n     *                          frame, this will shift the frames over to still attempt to cache\n     *                          the same amount.\n     *\n     * @param {array} skip      Frame IDs to ignore when assigning out frames to workers.\n     *                          Note that it is NOT GUARANTEED that these frames will be skipped\n     *                          by all workers - some may be returned by onFrames if they are between\n     *                          other unskipped frames.\n     */\n    extractFrames(frame, distance, skip) {\n        const iframe = parseInt(frame, 10);\n        const idle = this.getIdleWorkers();\n\n        log.info('Available workers', idle);\n\n        if (idle.length < 2) {\n            log.warning('Needs two idle workers, and no queue process yet. Quitting');\n            // TODO: Queue work\n            return;\n        }\n\n        // Lazy version (which might end up being the fastest)\n        // first worker will work forward: (frame, frame + distance]\n        // second worker will work backward: (frame - distance, frame]\n        // Hopefully, ignoring \"spin up\" time for ffmpeg to load a media file,\n        // the actual frame processing is fast enough to avoid adding more workers.\n        // This way - a 2 core CPU is sufficient (assuming the browser distributes\n        // worker threads across cores)\n\n\n        // Both workers will ignore skip for now, but it'd make sense as a minor optimization\n        // if skip was checked to see if we can just skip a worker altogether (e.g. everything\n        // before `frame` was cached, so don't run idle[0])\n\n        // in general - check if frames are already processed. Because if so - skip work.\n\n        const workPerThread = distance * 2 / idle.length;\n\n        for (let i = 0; i < idle.length; i++) {\n            const start = Math.floor(iframe - distance + (workPerThread * i));\n            const end = Math.floor(start + workPerThread + 1);\n            console.log('Worker', i, 'Range', start, 'to', end);\n\n            idle[i].postMessage({\n                type: 'job',\n                metadata: this.metadata,\n                start: start,\n                end: end\n            })\n        }\n\n        // idle[0].postMessage({\n        //     type: 'job',\n        //     metadata: this.metadata,\n        //     start: Math.floor(iframe - distance),\n        //     end: Math.floor(iframe)\n        // });\n\n        // idle[1].postMessage({\n        //     type: 'job',\n        //     metadata: this.metadata,\n        //     start: Math.floor(iframe),\n        //     end: Math.floor(iframe + distance)\n        // });\n    }\n\n    render() {\n        // return (\n        //     <div className=\"worker-pool\">\n        //         Running ({this.state.totalReady} / {this.props.workers}) Worker Threads\n        //     </div>\n        // );\n        return null;\n    }\n}\n\nWorkerPool.defaultProps = {\n    workers: 2\n};\n\nexport default WorkerPool;\n","// In production, we register a service worker to serve assets from local cache.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on the \"N+1\" visit to a page, since previously\n// cached resources are updated in the background.\n\n// To learn more about the benefits of this model, read https://goo.gl/KwvDNy.\n// This link also includes instructions on opting out of this behavior.\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport default function register() {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebookincubator/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Lets check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://goo.gl/SC7cgQ'\n          );\n        });\n      } else {\n        // Is not local host. Just register service worker\n        registerValidSW(swUrl);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the old content will have been purged and\n              // the fresh content will have been added to the cache.\n              // It's the perfect time to display a \"New content is\n              // available; please refresh.\" message in your web app.\n              console.log('New content is available; please refresh.');\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      if (\n        response.status === 404 ||\n        response.headers.get('content-type').indexOf('javascript') === -1\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","\nimport React from 'react';\n\nimport './Video.scss';\n\nimport Logger from './Log';\nconst log = new Logger('Video');\n\n/**\n * Video playback canvas. Not to be confused with native <video>\n * (TODO: ...should probably rename this)\n *\n * <Video onFrame={callable} onReady={callback}\n *      fps=\"29.98\" scale=\"1\" rotate=\"0\" translate={x: 0, y: 0} />\n *\n * `onReady` is fired once the media source has been fully loaded\n * `onFrame` callable gets the current frame number as an argument\n *\n * Supports frame caching (by way of being fed frames from an external source\n * such as an ffmpeg web worker or remote server)\n *\n * When this component has a cached version of a video frame, it will render\n * the cached frame before the original `video` element catches up - and then\n * replaces itself with the source frame once caught up. This allows\n * substantially faster scrubbing for video sources that may be complete\n * garbage at scrubbing in the browser otherwise (i.e.: everything).\n */\nclass Video extends React.Component {\n    constructor(props) {\n        super(props);\n\n        this.onVideoLoad = this.onVideoLoad.bind(this);\n        this.onVideoSeeked = this.onVideoSeeked.bind(this);\n        this.onAnimFrame = this.onAnimFrame.bind(this);\n        this.onImageLoad = this.onImageLoad.bind(this);\n\n        this.video = React.createRef();\n        this.canvas = React.createRef();\n        this.backbuffer = React.createRef();\n        this.image = React.createRef();\n\n        // Canvas context\n        this.context = null;\n        this.backbufferContext = null;\n\n        // State data not managed by React (need a faster response time here)\n        this.frames = {\n            total: 0,\n            start: 0,\n            end: 0\n        };\n\n        // Cached frame image URIs - by frame #\n        this.frameCache = {};\n        this.cacheFrameReady = false;\n        this.videoFrameReady = false;\n    }\n\n    componentDidMount() {\n        this.video.current.addEventListener('loadeddata', this.onVideoLoad, false);\n        this.video.current.addEventListener('seeked', this.onVideoSeeked, false);\n\n        this.image.current.addEventListener('load', this.onImageLoad, false);\n\n        // Set initial canvas transformation from props\n        this.transform(\n            this.props.translate,\n            this.props.scale,\n            this.props.rotate\n        );\n    }\n\n    /**\n     * Watch for component prop updates to update canvas transformation\n     */\n    componentDidUpdate(prevProps, prevState) {\n        // If any of the transformation props change, re-transform\n        if (prevProps.translate.x !== this.props.translate.x ||\n            prevProps.translate.y !== this.props.translate.y ||\n            prevProps.scale !== this.props.scale ||\n            prevProps.rotate !== this.props.rotate\n        ) {\n            this.transform(\n                this.props.translate,\n                this.props.scale,\n                this.props.rotate\n            );\n        }\n    }\n\n    onVideoLoad() {\n        const totalFrames = this.video.current.duration * this.props.fps;\n\n        console.log('Video loaded with', totalFrames, 'frames across', this.video.current.duration, 'seconds');\n\n        this.frames.total = totalFrames;\n        this.frames.end = totalFrames;\n\n        this.videoWidth = this.video.current.videoWidth;\n        this.videoHeight = this.video.current.videoHeight;\n        this.backbuffer.current.width = this.videoWidth * this.props.backbufferScale;\n        this.backbuffer.current.height = this.videoHeight * this.props.backbufferScale;\n\n        // Frame draw tracking\n        this.previousFrameTime = Date.now();\n        this.previousFrame = -1;\n        this.frame = 0;\n\n        // Draw the first frame\n        this.clearCanvas();\n        this.drawCurrentFrame();\n\n        // Notify listeners\n        if (this.props.onReady) {\n            this.props.onReady();\n        }\n    }\n\n    /**\n     * On seek - update our canvas with the new frame, overriding\n     * the cached frame that's possibly already rendered\n     */\n    onVideoSeeked() {\n        this.videoFrameReady = true;\n        this.drawCurrentFrame();\n    }\n\n    /**\n     * Callback for when the cache frame <img> src finishes loading\n     *\n     * This will render the cached image to canvas immediately,\n     * assuming the video source has not yet caught up.\n     */\n    onImageLoad() {\n        this.cacheFrameReady = true;\n        this.drawCurrentFrame();\n    }\n\n    /**\n     * Test if the given file resource can be loadable\n     *\n     * @param {File} file data to test\n     *\n     * @return {boolean}\n     */\n    canLoad(file) {\n        return this.video.current.canPlayType(file.type);\n    }\n\n    /**\n     * Load a new source to be played\n     *\n     * This will also clear the cache of the previously loaded source\n     *\n     * @param {string} src data to load\n     */\n    load(src) {\n        this.frameCache = {};\n        this.video.current.src = src;\n    }\n\n    /**\n     * Continue video playback\n     */\n    play() {\n        this.video.current.play();\n        this.requestId = window.requestAnimationFrame(this.onAnimFrame);\n    }\n\n    /**\n     * Pause video playback\n     */\n    pause() {\n        this.video.current.pause();\n        window.cancelAnimationFrame(this.requestId);\n    }\n\n    /**\n     * Return whether the video source is currently playing\n     *\n     * @return {boolean}\n     */\n    isPlaying() {\n        return !this.video.current.paused && !this.video.current.ended;\n    }\n\n    /**\n     * requestAnimationFrame handler to copy the video frame to our canvas\n     *\n     * This performs FPS limiting to only render at the speed of\n     * the source video's framerate.\n     */\n    onAnimFrame() {\n        const now = Date.now();\n        const delta = now - this.previousFrameTime;\n        const interval = 1000 / this.props.fps;\n\n        this.requestId = window.requestAnimationFrame(this.onAnimFrame);\n\n        if (delta > interval) {\n            this.previousFrameTime = now - (delta % interval);\n            this.drawCurrentFrame();\n\n            // Clamp playback between start & end frame range, looping\n            // whenever we run past the end frame.\n            if (this.frame < this.startFrame || this.frame > this.endFrame) {\n                this.frame = this.startFrame;\n            }\n        }\n    }\n\n    /**\n     * Apply a transformation to the canvas render of the video\n     *\n     * @param {object} translate {x, y} coordinate pair\n     * @param {float} scale\n     * @param {float} rotate\n     */\n    transform(translate, scale, rotate) {\n        const ctx = this.canvas.current.getContext('2d');\n\n        // Reset transformation\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n\n        // Apply transformations to the canvas\n        ctx.translate(translate.x, translate.y);\n        ctx.scale(scale, scale);\n        ctx.rotate(rotate);\n\n        // Redraw\n        this.clearCanvas();\n        this.drawCurrentFrame();\n    }\n\n    /**\n     * Clear video content from the canvas\n     */\n    clearCanvas() {\n        const ctx = this.canvas.current.getContext('2d');\n\n        ctx.save();\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.clearRect(0, 0, this.canvas.current.width, this.canvas.current.height);\n        ctx.restore();\n    }\n\n    /**\n     * Copy the current video frame to our canvas.\n     *\n     * If there is a cached frame ready to render and the video hasn't caught up,\n     * the cached frame will render first. For testing, we'll render the cache\n     * if it exists and ignore the video.\n     */\n    drawCurrentFrame() {\n        const ctx = this.canvas.current.getContext('2d');\n        // const backbufferContext = this.backbuffer.current.getContext('2d');\n\n        // Draw the cached frame if we have it and no higher quality source\n        // frame to draw (video still seeking)\n        if (this.cacheFrameReady && !this.videoFrameReady) {\n            ctx.drawImage(\n                this.image.current,\n                0,\n                0,\n                this.videoWidth,\n                this.videoHeight\n            );\n        } else {\n            ctx.drawImage(\n                this.video.current,\n                0,\n                0,\n                this.videoWidth,\n                this.videoHeight\n            );\n        }\n\n        // If there's an event handler for frame changes, call it.\n        if (this.frame !== this.previousFrame) {\n            this.previousFrame = this.frame;\n            if (this.props.onFrame) {\n                this.props.onFrame(this.frame);\n            }\n\n            // Frame change - and the video is caught up. Try to quickly add a local cache\n            if (this.videoFrameReady) {\n                if (!this.frameCache[this.frame]) {\n                    // HACK: Temporary\n                    // Just want to see perf stats across browsers\n                    // const backctx = this.backbuffer.current.getContext('2d');\n\n                    // backctx.drawImage(\n                    //     this.video.current,\n                    //     0,\n                    //     0,\n                    //     this.videoWidth * this.props.backbufferScale,\n                    //     this.videoHeight * this.props.backbufferScale\n                    // );\n\n                    // this.frameCache[this.frame] = this.backbuffer.current.toDataURL('image/jpg');\n\n                    // this.props.onFrameCache(this.frame);\n                }\n            }\n        }\n    }\n\n    /**\n     * Skip ahead/behind the specified number of frames\n     *\n     * @param {integer} count number of frames to skip forward/back\n     */\n    skip(count) {\n        this.frame = this.frame + count;\n    }\n\n    /**\n     * Load a series of URIs as frame caches\n     *\n     * If the series is longer than `len(end - start)`, anything\n     * outside that range will be discarded.\n     *\n     * Any existing cache will be overwritten by the new frames\n     *\n     * @param {Number} start frame number of the URIs\n     * @param {Number} end frame number of the URIs\n     * @param {array} frames series of URIs to cache, 0 indexed\n     */\n    cacheFrames(start, end, frames) {\n        // TODO: Faster than this loop\n        const len = Math.min(frames.length, end - start);\n\n        for (let i = 0; i < len; i++) {\n            this.frameCache[start + i] = frames[i];\n        }\n\n        // Dump results for debugging\n        log.debug('frameCache', Object.keys(this.frameCache));\n    }\n\n    /**\n     * Returns true if the given frame has been cached from any source\n     *\n     * @return {boolean}\n     */\n    isFrameCached(frame) {\n        return this.frameCache[frame] !== undefined;\n    }\n\n    /**\n     * Retrieve the start frame for playback clamping.\n     *\n     * Will be in range [0, endFrame)\n     *\n     * @return {integer}\n     */\n    get startFrame() {\n        return this.frames.start;\n    }\n\n    /**\n     * Set the start frame for playback clamping.\n     *\n     * Input value will be clamped to [0, endFrame)\n     *\n     * @param {integer} value\n     */\n    set startFrame(value) {\n        this.frames.start = Math.max(\n            0,\n            Math.min(value, this.endFrame - 1)\n        );\n    }\n\n    /**\n     * Retrieve the end frame for playback clamping.\n     *\n     * Will be in range (startFrame, totalFrames]\n     *\n     * @return {integer}\n     */\n    get endFrame() {\n        return this.frames.end;\n    }\n\n    /**\n     * Set the end frame for playback clamping.\n     *\n     * Input value will be clamped to (startFrame, totalFrames]\n     *\n     * @param {integer} value\n     */\n    set endFrame(value) {\n        this.frames.end = Math.max(\n            this.startFrame + 1,\n            Math.min(value, this.totalFrames)\n        );\n    }\n\n    /**\n     * Get the total number of frames in the video source\n     *\n     * @return {integer}\n     */\n    get totalFrames() {\n        return this.frames.total;\n    }\n\n    /**\n     * Retrieve the current frame number being rendered\n     */\n    get frame() {\n        if (this.video.current) {\n            return Math.round(this.video.current.currentTime * this.props.fps);\n        }\n\n        return 0;\n    }\n\n    /**\n     * Set the current frame to render and redraw\n     *\n     * Frame will be capped to range [startFrame, endFrame]\n     */\n    set frame(val) {\n        const frame = this.clampFrame(val);\n        this.video.current.currentTime = frame / this.props.fps;\n        this.videoFrameReady = false;\n\n        // If the frame is in our cache, load it into the worker <img>\n        // and flag the engine to render that image once ready\n        // if (this.isFrameCached(frame)) {\n        //     this.image.current.src = this.frameCache[frame];\n        //     this.cacheFrameReady = true;\n        // }\n\n        this.cacheFrameReady = this.isFrameCached(frame);\n        if (this.cacheFrameReady) {\n            this.image.current.src = this.frameCache[frame];\n        }\n    }\n\n    get speed() {\n        return this.video.current.playbackRate;\n    }\n\n    set speed(val) {\n        this.video.current.playbackRate = val;\n    }\n\n    /**\n     * Clamp the input frame to range [startFrame, endFrame]\n     *\n     * @return {integer} clamped frame\n     */\n    clampFrame(frame) {\n        return Math.max(this.startFrame, Math.min(frame, this.endFrame));\n    }\n\n    render() {\n        let sourcesDisplay = 'none';\n        if (this.props.showSources) {\n            sourcesDisplay = 'block';\n        }\n\n        return (\n            <div className=\"video\">\n                <canvas ref={this.canvas}\n                    width={this.props.width} height={this.props.height}\n                ></canvas>\n\n                <canvas ref={this.backbuffer} style={{ display: 'none' }}></canvas>\n\n                <div className=\"video-sources\" style={{ display: sourcesDisplay }}>\n                    <div className=\"video-source\">\n                        <div className=\"video-source-label\">Original Video</div>\n                        <video className=\"video-source-render\"\n                            ref={this.video} muted loop\n                        ></video>\n                    </div>\n\n                    <div className=\"video-source\">\n                        <div className=\"video-source-label\">Frame Cache</div>\n                        <img alt=\"frame\" className=\"video-source-render\" ref={this.image} />\n                    </div>\n                </div>\n            </div>\n        );\n    }\n}\n\nVideo.defaultProps = {\n    fps: 29.98,\n    width: 720,\n    height: 480,\n\n    translate: {\n        x: 0,\n        y: 0\n    },\n    scale: 1,\n    rotate: 0,\n\n    backbufferScale: 0.8,\n\n    showSources: false\n};\n\nexport default Video;\n","\n/**\n * Converter for time codes to frames and visa versa\n */\nclass Timecode {\n    constructor(fps) {\n        this.fps = fps;\n    }\n\n    /**\n     * Format a frame number to timecode\n     *\n     * @param {integer} frame\n     *\n     * @return {string}\n     */\n    to(frame) {\n        let seconds = frame / this.fps;\n        let minutes = seconds / 60;\n        let hours = minutes / 60;\n        let frames = Math.floor(frame % this.fps);\n        seconds = Math.floor(seconds % 60);\n        minutes = Math.floor(minutes % 60);\n        hours = Math.floor(hours % 24);\n\n        if (frames < 10) {\n            frames = '0' + frames;\n        }\n\n        if (seconds < 10) {\n            seconds = '0' + seconds;\n        }\n\n        if (minutes < 10) {\n            minutes = '0' + minutes;\n        }\n\n        if (hours < 10) {\n            hours = '0' + hours;\n        }\n\n        return `${hours}:${minutes}:${seconds}:${frames}`;\n    }\n\n    /**\n     * Convert a timecode to a frame number\n     *\n     * @param {string} timecode\n     *\n     * @return {integer}\n     */\n    from(timecode) {\n        let hours, minutes, seconds, frames;\n\n        [hours, minutes, seconds, frames] = timecode.split(':');\n\n        return parseInt(hours, 10) * 60\n            + parseInt(minutes, 10) * 60\n            + parseInt(seconds, 10) * this.fps\n            + parseInt(frames, 10);\n    }\n}\n\nexport default Timecode;\n","\nimport React from 'react';\nimport Timecode from './Timecode';\n\nimport './RangeSlider.scss';\n\n/**\n * Component to interactively pick a subset range of frames\n *\n * <RangeSlider fps=\"29.98\" min=\"0\" max=\"100\" onChange={callback} />\n *\n * `onChange` gets two integer arguments: `startFrame` and `endFrame`\n */\nclass RangeSlider extends React.Component {\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            start: props.min,\n            end: props.max\n        };\n\n        this.ref = React.createRef();\n\n        this.onUpdateSlider = this.onUpdateSlider.bind(this);\n        this.onChangeStartFrame = this.onChangeStartFrame.bind(this);\n        this.onChangeEndFrame = this.onChangeEndFrame.bind(this);\n        this.onChange = this.onChange.bind(this);\n    }\n\n    componentDidMount() {\n        // Setup noUiSlider\n        window.noUiSlider.create(this.ref.current, {\n            // Add support for offsetting the window\n            connect: true,\n            behaviour: 'drag',\n            tooltips: [this.getTooltipFormatter(), this.getTooltipFormatter()],\n\n            // Custom formatting for time codes\n            // format: {\n            //     to: (value) => this.frameToTimecode(value),\n            //     from: (value) => this.timecodeToFrame(value)\n            // }\n\n            // Disable slide animations (since we don't \"slide\" through source frames)\n            animate: false,\n\n            // Match full frame count\n            range: {\n                min: this.props.min * this.props.scale,\n                max: this.props.max * this.props.scale\n            },\n\n            start: [\n                this.state.start * this.props.scale,\n                this.state.end * this.props.scale\n            ],\n\n            // 20 frame margin between start and end\n            margin: 10,\n\n            step: this.props.scale\n        });\n\n        this.slider = this.ref.current.noUiSlider;\n\n        // Keep some DOM references for later update calculations\n        this.connector = this.slider.target.getElementsByClassName('noUi-connect')[0];\n        this.lowerHandle = this.slider.target.getElementsByClassName('noUi-handle-lower')[0];\n        this.upperHandle = this.slider.target.getElementsByClassName('noUi-handle-upper')[0];\n\n        this.slider.on('update', this.onUpdateSlider);\n\n        // Override event handling for the tooltips to prevent propagation\n        // (so click-dragging a tooltip won't function - only the handles will)\n        [].forEach.call(this.slider.target.getElementsByClassName('noUi-tooltip'), (el) => {\n            el.addEventListener('mousemove', RangeSlider.noop, true);\n            el.addEventListener('mousedown', RangeSlider.noop, true);\n        });\n    }\n\n    /**\n     * No-op event handler to stop event propagation when needed\n     * \n     * @param {Event} e \n     */\n    static noop(e) {\n        e.stopPropagation();\n        return false;\n    }\n\n    /**\n     * Formatter object for noUiSlider tooltips\n     */\n    getTooltipFormatter() {\n        return new Timecode(this.props.fps);\n    }\n\n    /**\n     * On prop update, also update our noUiSlider component\n     */\n    componentDidUpdate(prevProps) {\n        if (prevProps.min !== this.props.min || prevProps.max !== this.props.max) {\n            // Update noUiSlider to the new range limits\n            this.slider.updateOptions({\n                range: {\n                    min: this.props.min * this.props.scale,\n                    max: this.props.max * this.props.scale\n                },\n                start: [\n                    this.props.min * this.props.scale,\n                    this.props.max * this.props.scale\n                ],\n\n                // The larger our range, the higher our step count (1 vs 10)\n                // < 5000, by 1s, 5000 frames, by 5's, 10000 frames, by 10s,\n                // step: (this.props.max - this.props.min > 100) ? 10 : 1\n\n                // TODO:\n                // Step isn't what we want because manually setting a frame\n                // that isn't within the step (divisible by 10) sets it to the\n                // nearest divisible by ten value. Instead, we need something\n                // that has a smaller scrollable range (/10) but can manually\n                // enter numbers as fractions of that scrollable range, that are\n                // then multiplied by the scale (10)\n\n\n            }, false); // don't fire events for this\n\n            // Update state to fill in the new range\n            this.setState({\n                start: this.props.min,\n                end: this.props.max\n            });\n        }\n    }\n\n    /**\n     * Determine where and how to render handle labels based on the slider\n     * \n     * For \"short\" sliders, we'll push labels out of the connector, picking\n     * either the lower or upper bound as the target to push based on the \n     * connector's current position. \n     */\n    updateHandleLabels() {\n        // > 188px - can fit both labels in the connector\n        // > 118px - can fit a single label in the connector\n        // <= 118px - no labels in the connector \n        const width = this.connector.getBoundingClientRect().width;\n\n        // Connector interior is big enough for both labels\n        if (width > 188) {\n            this.lowerHandle.classList.remove('is-outside');\n            this.upperHandle.classList.remove('is-outside');\n            return;\n        }\n\n        // Only big enough for one label - pick one\n        if (width > 118) {\n            this.lowerHandle.classList.add('is-outside');\n            this.upperHandle.classList.remove('is-outside');\n            return;\n        }\n\n        // Too small for either label, remove both.\n        this.lowerHandle.classList.add('is-outside');\n        this.upperHandle.classList.add('is-outside');\n    }\n\n    onUpdateSlider(values) {\n        const start = Math.round(values[0] / this.props.scale);\n        const end = Math.round(values[1] / this.props.scale);\n\n        this.setState({ start, end });\n\n        this.updateHandleLabels();\n\n        // If we have a listener bound, fire a message to it\n        if (this.props.onChange) {\n            this.props.onChange(start, end);\n        }\n    }\n\n    onChange(e) {\n        this.setState({\n            [e.target.name]: e.target.value\n        });\n    }\n\n    onChangeStartFrame(e) {\n        this.slider.set([e.target.value * this.props.scale, null]);\n    }\n\n    onChangeEndFrame(e) {\n        this.slider.set([null, e.target.value * this.props.scale]);\n    }\n    \n\n    render() {\n        return (\n            <div className=\"range-slider\">\n                <input type=\"number\" name=\"min\" value={Math.round(this.props.min)} readOnly />\n                <input type=\"number\" name=\"start\" value={Math.round(this.state.start)}\n                    onChange={this.onChange} onBlur={this.onChangeStartFrame} />\n\n                <div ref={this.ref}></div>\n\n                <input type=\"number\" name=\"end\" value={Math.round(this.state.end)}\n                    onChange={this.onChange} onBlur={this.onChangeEndFrame} />\n                <input type=\"number\" name=\"max\" value={Math.round(this.props.max)} readOnly />\n            </div>\n        );\n    }\n}\n\nRangeSlider.defaultProps = {\n    min: 0,\n    max: 100,\n    scale: 1\n};\n\nexport default RangeSlider;\n","\nimport React from 'react';\nimport Timecode from './Timecode';\n\nimport './TimeSlider.scss';\n\n/**\n * Set keyframes within a time frame, and mark frames\n *\n * <TimeSlider onChange={callable} />\n *\n * `onChange` callable takes one argument: `frame`\n */\nclass TimeSlider extends React.Component {\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            start: 0,\n            end: 1,\n            current: 0,\n            currentInput: 0,\n\n            keys: {}\n        };\n\n        this.ref = React.createRef();\n\n        this.onSliderChange = this.onSliderChange.bind(this);\n        this.onInputChange = this.onInputChange.bind(this);\n        this.onInputBlur = this.onInputBlur.bind(this);\n        this.onClick = this.onClick.bind(this);\n    }\n\n    setRange(start, end) {\n        this.setState({\n            start: parseInt(start, 10),\n            end: parseInt(end, 10)\n        });\n    }\n\n    setFrame(frame) {\n        this.setState({\n            current: frame,\n            currentInput: frame\n        });\n    }\n\n    componentDidMount() {\n        // Setup noUiSlider\n        window.noUiSlider.create(this.ref.current, {\n            start: this.state.current,\n            step: 1,\n\n            tooltips: this.getTooltipFormatter(),\n\n            // Snap to position when a handle is clicked\n            behaviour: 'snap',\n\n            // Disable slide animations (since we don't \"slide\" through source frames)\n            animate: false,\n\n            // Match full frame count\n            range: {\n                min: this.state.start,\n                max: this.state.end\n            },\n\n            pips: this.getPips()\n\n            // padding: [ 0, 1 ]\n        });\n\n        this.slider = this.ref.current.noUiSlider;\n\n        // Extract the handle element from noUiSlider - we're going to be dynamically adjusting the CSS later\n        this.handle = this.slider.target.getElementsByClassName('noUi-handle')[0];\n\n        // Slide is included here so that the event gets fired while \"scrubbing\"\n        // See the event matrix on: https://refreshless.com/nouislider/events-callbacks/\n        this.slider.on('change', this.onSliderChange);\n        this.slider.on('slide', this.onSliderChange);\n\n        // Update current in case our input current is outside the acceptable range\n        this.setState({\n            current: parseInt(this.slider.get(), 10),\n            currentInput: parseInt(this.slider.get(), 10)\n        });\n    }\n\n    /**\n     * On prop update, also update our noUiSlider component\n     */\n    componentDidUpdate(prevProps, prevState) {\n        if (prevState.current !== this.state.current) {\n            this.slider.set(this.state.current);\n            this.updateHandleVisibility();\n        }\n\n        // Pass range changes off to noUiSlider\n        if (prevState.start !== this.state.start || prevState.end !== this.state.end) {\n            this.slider.updateOptions({\n                range: {\n                    min: this.state.start,\n                    max: this.state.end\n                }\n            });\n\n            // Update pip scaling\n            // Not supported via updateOptions.\n            // See https://github.com/leongersen/noUiSlider/issues/594\n            this.slider.pips(this.getPips(this.state.start, this.state.end));\n\n            // Make sure the handle is (in)visible based on whether\n            // or not it's in the updated range, and that it fits frame sizes\n            this.updateHandleVisibility();\n            this.updateHandleWidth();\n        }\n    }\n\n    /**\n     * Toggle visibility of the handle DOM based on whether our current frame\n     * is confined within the slider range (feature not available natively\n     * within noUiSlider).\n     */\n    updateHandleVisibility() {\n        if (!this.slider.target) {\n            return;\n        }\n\n        const handle = this.slider.target.getElementsByClassName('noUi-origin');\n\n        if (this.state.current >= this.state.start && this.state.current <= this.state.end) {\n            handle[0].classList.remove('is-off-timeline');\n            this.slider.set(this.state.current);\n        } else {\n            handle[0].classList.add('is-off-timeline');\n        }\n    }\n\n    /**\n     * Update the CSS width of the handle to match width of frames.\n     * \n     * Note that `min-width` is used within our CSS to ensure the handle doesn't underflow\n     * and become unclickable by the end user\n     */\n    updateHandleWidth() {\n        const { start, end } = this.state;\n        let width = 100 / (end - start) + '%';\n\n        this.handle.style.width = width;\n    }\n\n    /**\n     * Formatter object for noUiSlider tooltips\n     */\n    getTooltipFormatter() {\n        return new Timecode(this.props.fps);\n    }\n\n    /**\n     * Get the `pips` configuration for noUiSlider\n     *\n     * This will attempt to intelligently rescale pips to match Maya's behavior.\n     */\n    getPips(start, end) {\n        // Maya time slices like:\n        // by 1's up to 50 frames\n        // by 2's up to 100\n        // 5's up to 200\n        // 10s up to 500\n        // 20s up to 1000\n        // 50s up to 2000\n        // 100s up to 5000\n        // 200s up to 10000\n        // 500s up to ... etc\n\n        if (!start && !end) {\n            return null;\n        }\n\n        const range = end - start;\n        let factor = 1;\n        let step = 0;\n\n        // TODO: This algorithm is disgusting. Optimize.\n\n        while (true) {\n            if (range < 50 * factor) {\n                step = factor;\n                break;\n            } else if (range < 100 * factor) {\n                step = 2 * factor;\n                break;\n            } else if (range < 200 * factor) {\n                step = 5 * factor;\n                break;\n            }\n\n            factor *= 10;\n        }\n\n        let values = [];\n        for (let i = start; i <= end; i += step) {\n            values.push(i);\n        }\n\n        return {\n            mode: 'values',\n            values: values,\n            density: -1,\n        };\n    }\n\n    /**\n     * Event handler for when noUiSlider fires a `change` event\n     *\n     * Fires to onChange prop listener with the current frame as an argument\n     *\n     * @see https://refreshless.com/nouislider/events-callbacks/\n     *\n     * @param {string[]} value\n     */\n    onSliderChange(value) {\n        const ival = parseInt(value[0], 10);\n\n        // Only update if it's actually been changed.\n        if (this.state.current !== ival) {\n            this.setState({\n                current: ival,\n                currentInput: ival\n            });\n\n            if (this.props.onChange) {\n                this.props.onChange(ival);\n            }\n        }\n    }\n\n    /**\n     * Event handler for when the user types in the manual frame entry field\n     *\n     * This simply updates our state so that the field can be re-rendered.\n     *\n     * @param {Event} e\n     */\n    onInputChange(e) {\n        this.setState({\n            [e.target.name]: e.target.value\n        });\n    }\n\n    /**\n     * Event handler for when the user clicks out of the frame input\n     *\n     * Will update noUiSlider to the selected frame\n     *\n     * @param {Event} e\n     */\n    onInputBlur(e) {\n        this.slider.set(e.target.value);\n\n        if (this.props.onChange) {\n            this.props.onChange(parseInt(this.slider.get(), 10));\n        }\n    }\n\n    /**\n     * Set a frame as being keyed (colored on the timeline)\n     *\n     * @param {Number} frame\n     * @param {string} type Type string, will be used to identify keys on the DOM\n     *                      (as a data-type entry)\n     */\n    setKey(frame, type) {\n        const keys = this.state.keys;\n        keys[frame] = type;\n\n        // We're just setting state to itself here,\n        // but this'll trigger the redraw we need.\n        this.setState({ keys });\n    }\n\n    /**\n     * Returns true if the given frame has been keyed\n     *\n     * @param {Number} frame\n     *\n     * @return {boolean}\n     */\n    hasKey(frame) {\n        return frame in this.state.keys;\n    }\n\n    /**\n     * Remove key for a given frame\n     *\n     * @param {Number} frame\n     */\n    deleteKey(frame) {\n        const keys = this.state.keys;\n        delete keys[frame];\n\n        this.setState({ keys });\n    }\n\n    /**\n     * Remove all keys from the timeline and redraw\n     */\n    deleteAllKeys() {\n        this.setState({\n            keys: {}\n        });\n    }\n\n    /**\n     * Add custom markers to the slider for keyed frames\n     */\n    renderKeys() {\n        const { start, end } = this.state;\n\n        return (\n            <div className=\"time-slider-keys\">\n                {Object.keys(this.state.keys).map((frame) => {\n                    const type = this.state.keys[frame];\n\n                    if (frame >= start && frame <= end) {\n                        return (\n                            <div key={frame} className=\"time-slider-key\" style={{\n                                left: ((frame - start) / (end - start) * 100) + '%',\n                                width: 100 / (end - start) + '%',\n                            }} data-type={type} data-frame={frame}></div>\n                        );\n                    }\n\n                    return null;\n                })}\n            </div>\n        );\n    }\n\n    onClick(e) {\n        // If we clicked on a key frame, jump to it\n        if (e.target.dataset.frame) {\n            const frame = e.target.dataset.frame;\n\n            // Only update if it's actually been changed.\n            if (this.state.current !== frame) {\n                this.setState({\n                    current: frame,\n                    currentInput: frame\n                });\n\n                if (this.props.onChange) {\n                    this.props.onChange(frame);\n                }\n            }\n        }\n    }\n\n    render() {\n        return (\n            <div className=\"time-slider\" onClick={this.onClick}>\n                <div className=\"time-slider-noui\">\n                    <div ref={this.ref}></div>\n                    {this.renderKeys(this.props.keys)}\n                </div>\n\n                <input type=\"number\" name=\"currentInput\" value={this.state.currentInput}\n                    onChange={this.onInputChange} onBlur={this.onInputBlur} />\n            </div>\n        );\n    }\n}\n\nTimeSlider.defaultProps = {\n    keys: []\n};\n\nexport default TimeSlider;\n","\nimport React from 'react';\n\nimport './Draw.scss';\n\nimport Logger from './Log';\nconst log = new Logger('Draw');\n\n/**\n * Frame drawover\n *\n * <Draw width=\"720\" height=\"480\" readonly={boolean}\n *       scale=\"1\" rotate=\"0\" translate={x: 0, y: 0}\n *       source={ArrayBuffer}\n *       onDraw={callable} onClear={callable} />\n *\n * Includes basic draw tools:\n *  - brush size\n *  - brush color\n *  - eraser\n *\n * Includes a history stack for undo/redo and storing\n * strokes in a more lightweight data format than a canvas image.\n */\nclass Draw extends React.Component {\n    static PEN_TOOL = 1;\n    static ERASE_TOOL = 2;\n    static CLEAR_TOOL = 3;\n\n    constructor(props) {\n        super(props);\n\n        this.penColors = [\n            '#FF0000',\n            '#00FF00',\n            '#0000FF',\n            '#000000',\n            '#FFFFFF'\n        ];\n\n        this.state = {\n            // Active tool information\n            tool: null,\n            color: null,\n            lineWidth: 5,\n\n            previousTool: 'pen',\n\n            // Undo stack / serializable stroke info\n            history: [],\n\n            // Where we are in the undo stack\n            historyIndex: 0,\n\n            empty: true\n        };\n\n        // These are kept out of state since they're localized\n        // only to the canvas element and updated very frequently\n        this.points = [];\n        this.dragging = false;\n        this.mouseX = 0;\n        this.mouseY = 0;\n\n        this.matrix = new window.DOMMatrixReadOnly();\n\n        this.canvas = React.createRef();\n        this.temp = React.createRef();\n\n        this.onMouseMove = this.onMouseMove.bind(this);\n        this.onMouseUp = this.onMouseUp.bind(this);\n        this.onMouseDown = this.onMouseDown.bind(this);\n        this.onTouchStart = this.onTouchStart.bind(this);\n        this.onTouchEnd = this.onTouchEnd.bind(this);\n        this.onTouchMove = this.onTouchMove.bind(this);\n        this.onTouchCancel = this.onTouchCancel.bind(this);\n        this.onKeyDown = this.onKeyDown.bind(this);\n        this.onChangeLineWidth = this.onChangeLineWidth.bind(this);\n        this.onClear = this.onClear.bind(this);\n        this.onContextMenu = this.onContextMenu.bind(this);\n        this.undo = this.undo.bind(this);\n        this.redo = this.redo.bind(this);\n    }\n\n    componentDidMount() {\n        // Set initial canvas transformation from props\n        this.transform(\n            this.props.translate,\n            this.props.scale,\n            this.props.rotate\n        );\n\n        // Add non-React event listener for context menu\n        // (right click) and a default pen\n        if (!this.props.readonly) {\n            this.setPen(this.penColors[0]);\n            this.temp.current.addEventListener('contextmenu', this.onContextMenu);\n        }\n\n        // If there was a preloaded serialized form of this\n        // Draw to load from, render it on mount\n        if (this.props.source) {\n            this.deserialize(this.props.source);\n        }\n    }\n\n    /**\n     * Watch for component state updates to update associated canvas elements\n     */\n    componentDidUpdate(prevProps, prevState) {\n\n        // On tool change or line width change, update our custom cursor to match\n        if (prevState.tool !== this.state.tool ||\n            prevState.lineWidth !== this.state.lineWidth\n        ) {\n            this.redrawCursorSVG();\n        }\n\n        // If any of the transformation props change, re-transform\n        if (prevProps.translate.x !== this.props.translate.x ||\n            prevProps.translate.y !== this.props.translate.y ||\n            prevProps.scale !== this.props.scale ||\n            prevProps.rotate !== this.props.rotate\n        ) {\n            this.transform(\n                this.props.translate,\n                this.props.scale,\n                this.props.rotate\n            );\n        }\n\n        // If history updated, update the cached empty status\n        if (prevState.historyIndex !== this.state.historyIndex) {\n            this.setState({\n                empty: this.isEmpty()\n            });\n        }\n    }\n\n    /**\n     * Clear the temporary canvas used for storing the current line\n     */\n    clearTemp() {\n        const ctx = this.tempContext;\n\n        if (ctx) {\n            ctx.save();\n            ctx.setTransform(1, 0, 0, 1, 0, 0);\n            ctx.clearRect(0, 0, this.temp.current.width, this.temp.current.height);\n            ctx.restore();\n        }\n    }\n\n    /**\n     * End the current line being drawn with the pen or eraser tools\n     *\n     * This will copy whatever is rendered on the temp canvas\n     * onto the main canvas, and clear the temp.\n     */\n    endCurrentLine() {\n        if (!this.points.length) {\n            return;\n        }\n\n        const ctx = this.canvasContext;\n\n        // Add line to our history stack\n        this.pushHistory(\n            this.state.tool,\n            this.state.color,\n            this.state.lineWidth,\n            this.points\n        );\n\n        // Copy temp canvas contents onto the composite canvas\n        ctx.globalCompositeOperation = 'source-over';\n\n        ctx.save();\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.drawImage(this.temp.current, 0, 0);\n        ctx.restore();\n\n        // Reset everything\n        this.clearTemp();\n        this.points = [];\n\n        // Fire the onDraw event listener, if present\n        if (this.props.onDraw) {\n            this.props.onDraw();\n        }\n    }\n\n    /**\n     * Start drawing once the canvas is left clicked\n     *\n     * @param {SyntheticEvent} e\n     */\n    onMouseDown(e) {\n        // If we click outside the visible tools window,\n        // just close it and don't start drawing.\n        if (this.state.toolsVisible) {\n            this.setState({\n                toolsVisible: false\n            });\n            return;\n        }\n\n        if (e.buttons === 1) {\n            this.dragging = true;\n        }\n\n        if (this.dragging) {\n            this.trackMouse(e);\n            this.draw();\n        }\n    }\n\n    /**\n     * Stop drawing a line on the canvas\n     *\n     * This event is triggered for both the button up event and\n     * the mouse leaving the canvas (onMouseOut) since we want\n     * to treat both as a line ender.\n     *\n     * @param {SyntheticEvent} e\n     */\n    onMouseUp(e) {\n        if (this.dragging) {\n            this.dragging = false;\n            this.endCurrentLine();\n        }\n    }\n\n    /**\n     * Track the mouse position on movement\n     *\n     * @param {SyntheticEvent} e\n     */\n    onMouseMove(e) {\n        if (this.state.toolsVisible) {\n            return;\n        }\n\n        // If they had the primary mouse button down while dragging INTO\n        // the canvas, but didn't press it down while already on the canvas,\n        // flag as a drag event\n        if (e.buttons === 1) {\n            this.dragging = true;\n        }\n\n        this.trackMouse(e);\n\n        if (this.dragging) {\n            this.draw();\n        }\n    }\n\n    /**\n     * Finger(s) down for touch input\n     *\n     * @param {SyntheticEvent} e\n     */\n    onTouchStart(e) {\n        log.debug('Touch Start', e);\n        const touches = e.changedTouches;\n\n        // If we're not tracking touch yet, track first\n        if (!this.touchIdentifier) {\n            this.touchIdentifier = touches[0].identifier;\n\n            this.dragging = true;\n            this.trackTouch(touches[0]);\n            this.draw();\n        }\n\n        // Everything else - we ignore. Single touch only\n    }\n\n    /**\n     * Finger lifts from touch input\n     *\n     * @param {SyntheticEvent} e\n     */\n    onTouchEnd(e) {\n        log.debug('Touch End', e);\n        const touches = e.changedTouches;\n\n        // If our tracked touch was lifted, end the line\n        for (let i = 0; i < touches.length; i++) {\n            if (touches[i].identifier === this.touchIdentifier) {\n                this.touchIdentifier = null;\n                this.dragging = false;\n                this.endCurrentLine();\n            }\n        }\n    }\n\n    /**\n     * Finger(s) leave the touch region\n     *\n     * @param {SyntheticEvent} e\n     */\n    onTouchCancel(e) {\n        log.debug('Touch Cancel', e);\n        this.onTouchEnd(e);\n    }\n\n    /**\n     * Keyboard touch move event - draw more lines\n     *\n     * @param {SyntheticEvent} e\n     */\n    onTouchMove(e) {\n        const touches = e.changedTouches;\n\n        for (let i = 0; i < touches.length; i++) {\n            if (touches[i].identifier === this.touchIdentifier) {\n                this.trackTouch(touches[i]);\n                this.draw();\n            }\n        }\n    }\n\n    /**\n     * Capture and respond to undo/redo events (ctrl+z/y)\n     *\n     * @param {SyntheticEvent} e\n     */\n    onKeyDown(e) {\n        if (e.keyCode === 90 && e.ctrlKey) { // ctrl+z or cmd+z\n            this.undo();\n        } else if (e.keyCode === 89 && e.ctrlKey) { // ctrl+y or cmd+shift+z\n            this.redo();\n        } else if (e.keyCode === 27) { // ESC - hide tools if visible\n            this.setState({\n                toolsVisible: false\n            });\n        }\n    }\n\n    /**\n     * Override the default context menu with a tool menu\n     *\n     * @param {SyntheticEvent} e\n     */\n    onContextMenu(e) {\n        e.preventDefault();\n\n        // TODO: Smarter placement, in case it's offscreen or something.\n        this.setState({\n            toolsVisible: true,\n            toolsOrigin: {\n                top: e.pageY,\n                left: e.pageX\n            }\n        });\n\n        return false;\n    }\n\n    /**\n     * Store the current position of the mouse as a point on the canvas\n     *\n     * @param {SyntheticEvent} e\n     */\n    trackMouse(e) {\n        const point = this.transformedPoint(\n            e.nativeEvent.offsetX,\n            e.nativeEvent.offsetY\n        );\n\n        this.mouseX = point.x;\n        this.mouseY = point.y;\n    }\n\n    trackTouch(touch) {\n        const point = this.transformedPoint(\n            touch.pageX - touch.target.offsetLeft,\n            touch.pageY - touch.target.offsetTop\n        );\n\n        this.mouseX = point.x;\n        this.mouseY = point.y;\n    }\n\n    /**\n     * Clear both canvas but persist draw history\n     */\n    clear() {\n        const ctx = this.canvasContext;\n\n        ctx.save();\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.clearRect(0, 0, this.canvas.current.width, this.canvas.current.height);\n        ctx.restore();\n\n        this.clearTemp();\n    }\n\n    /**\n     * Redraw the main canvas up to `historyIndex`\n     *\n     * @param {Number} historyIndex in range [0, history.length]\n     */\n    redraw(historyIndex) {\n        const ctx = this.canvasContext;\n\n        this.clear();\n\n        // Run through the history and redraw each tool onto the main canvas\n        for (let i = 0; i < historyIndex; i++) {\n            const event = this.state.history[i];\n\n            if (event.tool === Draw.ERASE_TOOL) {\n                this.pen(\n                    ctx,\n                    '',\n                    event.lineWidth,\n                    event.points,\n                    'destination-out'\n                );\n            } else if (event.tool === Draw.PEN_TOOL) {\n                this.pen(\n                    ctx,\n                    event.color,\n                    event.lineWidth,\n                    event.points,\n                    'source-over'\n                );\n            } else if (event.tool === Draw.CLEAR_TOOL) {\n                this.clear();\n            }\n        }\n    }\n\n    /**\n     * Perform a pen tool draw operation on the desired canvas\n     *\n     * A quadratic curve is drawn through `points` to create\n     * a smooth curve across the canvas\n     *\n     * This also supports an erase tool by changing the canvas\n     * operation that the stroke utilizes to `destination-out`\n     *\n     * @param {CanvasContext2D} ctx         Target canvas context\n     * @param {string}          color       Hex color code\n     * @param {Number}          lineWidth   Stroke size of the pen\n     * @param {array}           points      Array of {x, y} pairs in canvas space\n     * @param {string}          operation   A globalCompositeOperation for the\n     *                                      stroke (e.g. `source-over`)\n     */\n    pen(ctx, color, lineWidth, points, operation) {\n        let cpx, cpy, x, y;\n        let i = 1;\n\n        ctx.lineWidth = lineWidth;\n        ctx.lineJoin = 'round';\n        ctx.lineCap = 'round';\n        ctx.strokeStyle = color;\n        ctx.fillStyle = color;\n\n        ctx.globalCompositeOperation = operation;\n\n        // If not enough points for a curve, just make a dot\n        if (points.length < 3) {\n            ctx.beginPath();\n            ctx.arc(\n                points[0].x,\n                points[0].y,\n                lineWidth / 2,\n                0,\n                Math.PI * 2\n            );\n\n            ctx.fill();\n            ctx.closePath();\n            return;\n        }\n\n        ctx.beginPath();\n        ctx.moveTo(points[0].x, points[0].y);\n\n        for (i; i < points.length - 2; i++) {\n            // Control point coordinate\n            cpx = points[i].x;\n            cpy = points[i].y;\n\n            // End point coordinate - midpoint between two points\n            x = (cpx + points[i + 1].x) / 2;\n            y = (cpy + points[i + 1].y) / 2;\n\n            ctx.quadraticCurveTo(cpx, cpy, x, y);\n        }\n\n        // Draw a curve for the last two\n        cpx = points[i].x;\n        cpy = points[i].y;\n        x = points[i + 1].x;\n        y = points[i + 1].y;\n\n        ctx.quadraticCurveTo(cpx, cpy, x, y);\n        ctx.stroke();\n    }\n\n    /**\n     * Interactive draw update with the currently selected tool\n     */\n    draw() {\n        this.points.push({\n            x: this.mouseX,\n            y: this.mouseY\n        });\n\n        if (this.state.tool === Draw.ERASE_TOOL) {\n            // Erase tool operates directly on the composite canvas\n            // so that it can immediately overwrite existing lines.\n            // The edges are slightly more jagged and overdraw themselves\n            // while moving the pen, but that's typically alright.\n            this.pen(\n                this.canvasContext,\n                '',\n                this.state.lineWidth,\n                this.points,\n                'destination-out'\n            );\n        } else {\n            // Clear the temp and start a new curve from all the\n            // stored points for a smoother curve\n            this.clearTemp();\n\n            this.pen(\n                this.tempContext,\n                this.state.color,\n                this.state.lineWidth,\n                this.points,\n                'source-over'\n            );\n        }\n    }\n\n    /**\n     * Activate a pen tool in the chosen color\n     *\n     * @param {string} color Hex color code to draw in\n     */\n    setPen(color) {\n        this.setState({\n            tool: Draw.PEN_TOOL,\n            color: color,\n\n            // Clear tools menu, if still active\n            toolsVisible: false\n        });\n    }\n\n    /**\n     * Activate the eraser tool\n     */\n    setEraser() {\n        this.setState({\n            tool: Draw.ERASE_TOOL,\n            color: '',\n\n            // Clear tools menu, if still active\n            toolsVisible: false\n        });\n    }\n\n    /**\n     * Tools menu event handler to change state.lineWidth\n     *\n     * @param {SyntheticEvent} e\n     */\n    onChangeLineWidth(e) {\n        const ctx = this.canvas.current.getContext('2d');\n        const tempCtx = this.temp.current.getContext('2d');\n\n        ctx.lineWidth = e.target.value;\n        tempCtx.lineWidth = e.target.value;\n\n        this.setState({\n            lineWidth: e.target.value\n        });\n    }\n\n    /**\n     * Add a new stroke or operation to the history stack\n     *\n     * @param {Number} tool One of the *_TOOL constants\n     * @param {string} color Hex color code (if PEN_TOOL)\n     * @param {Number} lineWidth Stroke size\n     * @param {array} points {x, y} coordinate pairs (canvas space)\n     */\n    pushHistory(tool, color, lineWidth, points) {\n        const history = this.state.history;\n        let historyIndex = this.state.historyIndex;\n\n        // If they rolled back the history, drop everything\n        // after the index and replace with the new event\n        if (historyIndex < history.length) {\n            history.splice(historyIndex);\n        }\n\n        history.push({\n            tool,\n            color,\n            lineWidth,\n            points\n        });\n\n        historyIndex++;\n\n        this.setState({ history, historyIndex });\n    }\n\n    /**\n     * Walk backwards in the history stack and redraw\n     */\n    undo() {\n        let historyIndex = this.state.historyIndex - 1;\n\n        if (historyIndex < 0) {\n            historyIndex = 0;\n        }\n\n        this.setState({ historyIndex });\n        this.redraw(historyIndex);\n\n        // if we `undo` to a clear event or an empty canvas, fire onClear\n        if (historyIndex < 1 || this.state.history[historyIndex].tool === Draw.ERASE_TOOL) {\n            if (this.props.onClear) {\n                this.props.onClear();\n            }\n        } else if (this.props.onDraw) {\n            // Otherwise - we undo some pen event, consider it a draw.\n            this.props.onDraw();\n        }\n    }\n\n    /**\n     * Walk forwards in the history stack and redraw\n     */\n    redo() {\n        let historyIndex = this.state.historyIndex + 1;\n\n        if (historyIndex > this.state.history.length) {\n            historyIndex = this.state.history.length;\n        }\n\n        this.setState({ historyIndex });\n        this.redraw(historyIndex);\n\n        // If we redo a 'clear' event, fire onClear\n        if (this.state.history[historyIndex].tool === Draw.ERASE_TOOL) {\n            if (this.props.onClear) {\n                this.props.onClear();\n            }\n        } else if (this.props.onDraw) {\n            // redoed to some pen event, fire a draw\n            this.props.onDraw();\n        }\n    }\n\n    /**\n     * Clear the canvas and the history stack.\n     *\n     * This will still maintain whatever the active tool was.\n     */\n    reset() {\n        this.clear();\n        this.setState({\n            history: [],\n            historyIndex: 0\n        });\n    }\n\n    /**\n     * Returns true if there is currently no rendered content\n     *\n     * @return {boolean}\n     */\n    isEmpty() {\n        if (this.state.historyIndex < 1) {\n            return true;\n        }\n\n        const lastTool = this.state.history[this.state.historyIndex - 1].tool;\n\n        // Consider us \"empty\" if the last tool was a clear.\n        if (lastTool === Draw.CLEAR_TOOL) {\n            return true;\n        }\n\n        // If it's a pen, we know we're not empty\n        if (lastTool === Draw.PEN_TOOL) {\n            return false;\n        }\n\n        // Otherwise - it's an erase. No way to know for\n        // certain without testing the canvas pixels.\n        // Can create (and cache) a `toDataURL` of a blank canvas and\n        // compare that to our data URL of this canvas.\n\n        // .. But this is slow. And we call this method often (every\n        // history stack update) so for now, we'll assume it's not empty\n        return true;\n    }\n\n    /**\n     * Create a serialized form of `history` we can reuse later\n     *\n     * This attempts to eliminate some of the fat from `history`\n     * to reduce serialized size.\n     *\n     * @return {ArrayBuffer}\n     */\n    serialize() {\n        /*\n            Byte count is:\n\n            tool: 1 byte\n            color: 3 bytes\n            lineWidth: 1 byte\n            point length: 2 bytes\n            points: 4 bytes per point\n\n            For laziness, everything will be padded to int16,\n            so tool/linewidth = 2 bytes, color = 6 bytes, and color/point length will\n            be in every event, regardless of type. Will overoptimize later.\n        */\n\n        let buffer = [];\n\n        // TODO: Better handle \"erase\" events s.t. if an erasure actually\n        // clears the entire canvas, don't store anything prior to erase\n        for (let i = 0; i < this.state.historyIndex; i++) {\n            const event = this.state.history[i];\n\n            if (event.tool === Draw.CLEAR_TOOL) {\n                buffer = [];\n            } else {\n                buffer.push(event.tool);\n                buffer.push(parseInt(event.color.substr(1, 2), 16)); // R\n                buffer.push(parseInt(event.color.substr(3, 2), 16)); // G\n                buffer.push(parseInt(event.color.substr(5, 2), 16)); // B\n                buffer.push(event.lineWidth);\n                buffer.push(event.points.length * 2); // int16 length of points\n\n                for (let p = 0; p < event.points.length; p++) {\n                    buffer.push(event.points[p].x);\n                    buffer.push(event.points[p].y);\n                }\n            }\n        }\n\n        // TODO: Some sort of compression?\n        return new Int16Array(buffer).buffer;\n    }\n\n    /**\n     * Deserialize the input history state and redraw to match\n     *\n     * @param {ArrayBuffer} buffer\n     */\n    deserialize(buffer) {\n        const int16 = new Int16Array(buffer);\n        const deserialized = [];\n\n        let i = 0;\n\n        while (i < int16.length) {\n            // Read event header\n            const event = {\n                tool: int16[i],\n                color: '#' +\n                    int16[i + 1].toString(16).padStart(2, '0') +\n                    int16[i + 2].toString(16).padStart(2, '0') +\n                    int16[i + 3].toString(16).padStart(2, '0'),\n                lineWidth: int16[i + 4]\n            };\n\n            i += 5;\n\n            // Read point data\n            const plen = int16[i];\n            const points = [];\n\n            i++;\n            for (let p = 0; p < plen; p += 2) {\n                points.push({\n                    x: int16[i + p],\n                    y: int16[i + p + 1]\n                });\n            }\n\n            event.points = points;\n            i += plen;\n\n            deserialized.push(event);\n        }\n\n        // Rewrite history and redraw\n        this.setState({\n            history: deserialized,\n            historyIndex: deserialized.length\n        }, () => this.redraw(deserialized.length));\n    }\n\n    /**\n     * Tools menu event to clear the canvas\n     */\n    onClear() {\n        this.clear();\n        this.pushHistory(Draw.CLEAR_TOOL, '', '', []);\n\n        // Hide the tools menu, if visible\n        this.setState({\n            toolsVisible: false\n        });\n\n        // Fire off the `onClear` listener, if present\n        if (this.props.onClear) {\n            this.props.onClear();\n        }\n    }\n\n    /**\n     * Load up a new SVG as our custom cursor based on the active tool\n     *\n     * This will create a new SVG instance and apply it to state.cursor\n     */\n    redrawCursorSVG() {\n        const size = parseInt(this.state.lineWidth * this.props.scale, 10);\n        const rad = size / 2;\n        const padding = 2;\n\n        // Photoshop-esque circle that matches the line width.\n        // It doesn't invert itself on dark backgrounds, so instead we give it\n        // a white blur around the edges to make it still visible.\n        const svg = `\n            <svg version=\"1.1\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\"\n                xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n                x=\"0\" y=\"0\" width=\"${size+padding*2}px\" height=\"${size+padding*2}px\"\n                xml:space=\"preserve\"\n            >\n                <defs>\n                    <filter id=\"blur\" x=\"0\" y=\"0\" filterUnits=\"userSpaceOnUse\">\n                        <feGaussianBlur stdDeviation=\"1\" />\n                    </filter>\n                </defs>\n                <circle cx=\"${rad+padding}\" cy=\"${rad+padding}\" r=\"${rad-1}\"\n                    stroke=\"white\"\n                    fill=\"transparent\"\n                    stroke-width=\"0.8\"\n                    filter=\"url(#blur)\"\n                />\n                <circle cx=\"${rad+padding}\" cy=\"${rad+padding}\" r=\"${rad-1}\"\n                    stroke=\"black\"\n                    fill=\"transparent\"\n                    stroke-width=\"1\"\n                />\n            </svg>\n        `;\n\n        // Debug rect\n        // <rect width=\"${size+padding*2}px\" height=\"${size+padding*2}\" stroke=\"green\" stroke-width=\"3\" fill=\"transparent\" />\n\n        this.setState({\n            cursor: `url(\"data:image/svg+xml,${encodeURI(svg)}\") ${rad+padding} ${rad+padding}, crosshair`\n        });\n    }\n\n    get canvasContext() {\n        return this.canvas.current.getContext('2d');\n    }\n\n    /**\n     * Get the context of the temp canvas.\n     *\n     * This will return null if the component was rendered\n     * without a temp canvas (e.g. in `readonly` mode)\n     *\n     * @return {CanvasContext2D|null}\n     */\n    get tempContext() {\n        if (!this.temp.current) {\n            return null;\n        }\n\n        return this.temp.current.getContext('2d');\n    }\n\n    /**\n     * Apply a transformation to the canvas\n     *\n     * This transformation will replace whatever the previous\n     * canvas transformation was. Used with components like\n     * Transform to apply canvas transformations uniformly\n     * with other DOM components.\n     *\n     * Currently, transformations are done in TSR order.\n     *\n     * @param {object} translate {x, y} coordinate pair\n     * @param {Number} scale Canvas scale, where 1 is no scale\n     * @param {Number} rotate Radian rotation\n     */\n    transform(translate, scale, rotate) {\n        const canvasCtx = this.canvasContext;\n        const tempCtx = this.tempContext;\n\n        // Apply transformations to all three matrices\n        this.matrix = new window.DOMMatrixReadOnly();\n        this.matrix = this.matrix.translate(translate.x, translate.y);\n        this.matrix = this.matrix.scale(scale, scale);\n        this.matrix = this.matrix.rotate(rotate * 180 / Math.PI);\n\n        canvasCtx.setTransform(1, 0, 0, 1, 0, 0);\n        canvasCtx.translate(translate.x, translate.y);\n        canvasCtx.scale(scale, scale);\n        canvasCtx.rotate(rotate);\n\n        if (tempCtx) {\n            tempCtx.setTransform(1, 0, 0, 1, 0, 0);\n            tempCtx.translate(translate.x, translate.y);\n            tempCtx.scale(scale, scale);\n            tempCtx.rotate(rotate);\n        }\n\n        this.redraw(this.state.historyIndex);\n        this.redrawCursorSVG();\n    }\n\n    /**\n     * Convert a DOM-space point to canvas local space\n     *\n     * @param {Number} x\n     * @param {Number} y\n     */\n    transformedPoint(x, y) {\n        const inv = this.matrix.inverse();\n\n        return new window.DOMPoint(\n            x * inv.a + y * inv.c + inv.e,\n            x * inv.b + y * inv.d + inv.f,\n            0, 1\n        );\n    }\n\n    /**\n     * Render a panel that contains our history stack\n     *\n     * For debugging use only, ATM\n     */\n    renderHistory() {\n        const { history, historyIndex } = this.state;\n\n        return (\n            <ul className=\"draw-history\">\n                {history.map((event, idx) =>\n                    <li key={idx} className={idx >= historyIndex ? 'is-undone' : ''}>\n                        {idx}:\n\n                        {idx === historyIndex &&\n                            <span>*</span>\n                        }\n\n                        {event.tool} - {event.color} -\n                        {event.lineWidth} - {event.points.length}\n                    </li>\n                )}\n            </ul>\n        );\n    }\n\n    /**\n     * Render the floating tools menu\n     */\n    renderTools() {\n        const { tool, color, lineWidth } = this.state;\n\n        return (\n            <div className=\"draw-tools\" style={this.state.toolsOrigin}>\n                <input type=\"range\" min=\"1\" max=\"100\"\n                    className=\"draw-line-width\"\n                    value={lineWidth}\n                    onChange={this.onChangeLineWidth} />\n\n                <ul>\n                {this.penColors.map((c) =>\n                    <li key={c}>\n                        <button className={'draw-pen ' +\n                            (color === c && tool === Draw.PEN_TOOL ? 'is-active' : '')\n                        } onClick={() => this.setPen(c)} style={{backgroundColor: c}}></button>\n                    </li>\n                )}\n                </ul>\n\n                <button className={'draw-eraser ' + (tool === Draw.PEN_TOOL ? 'is-active' : '')}\n                    onClick={() => this.setEraser()}>Eraser</button>\n\n                <button className=\"draw-clear\" onClick={this.onClear}>Clear</button>\n\n                <button className=\"draw-undo\" onClick={this.undo}>Undo</button>\n                <button className=\"draw-redo\" onClick={this.redo}>Redo</button>\n            </div>\n        );\n    }\n\n    render() {\n        // Temp canvas is rendered directly on top of the main canvas so that\n        // it gets input events and drawn lines are copied down to the underlying\n        // persistent canvas. The temp canvas and all its event handlers will NOT\n        // be rendered if this canvas is in readonly mode.\n        return (\n            <div className=\"draw\" style={{ opacity: this.props.opacity }}>\n                {!this.props.readonly &&\n                    <canvas ref={this.temp} className=\"draw-temp\" tabIndex=\"0\"\n                        width={this.props.width} height={this.props.height}\n                        onMouseMove={this.onMouseMove}\n                        onMouseDown={this.onMouseDown}\n                        onMouseUp={this.onMouseUp}\n                        onMouseLeave={this.onMouseUp}\n                        onTouchStart={this.onTouchStart}\n                        onTouchEnd={this.onTouchEnd}\n                        onTouchMove={this.onTouchMove}\n                        onTouchCancel={this.onTouchCancel}\n                        onKeyDown={this.onKeyDown}\n                        style={{\n                            cursor: this.state.cursor\n                        }}\n                    ></canvas>\n                }\n\n                <canvas ref={this.canvas} className=\"draw-canvas\"\n                    width={this.props.width} height={this.props.height}></canvas>\n\n                {this.state.toolsVisible && this.renderTools()}\n            </div>\n        );\n    }\n}\n\nDraw.defaultProps = {\n    readonly: false,\n    source: null,\n    opacity: 1,\n\n    width: 720,\n    height: 480,\n\n    translate: {\n        x: 0,\n        y: 0\n    },\n    scale: 1,\n    rotate: 0,\n\n    onDraw: null,\n    onClear: null\n};\n\nexport default Draw;\n","\nimport React from 'react';\n\n/**\n * Component that controls matrix transforms of children\n *\n * All children are expected to have `translate`, `scale`, `rotate`\n * properties that are updated as this component accepts user input\n * to update transformations.\n *\n * Transformation can be controlled and updated by input shortcuts:\n *  - Pan (translate): Shift + Mouse Move\n *  - Zoom (scale): Shift + Scroll Wheel\n *  - Rotate: TBD\n *\n * Example:\n *  <Transform>\n *      <Draw ... />\n *      <Video ... />\n *  </Transform>\n */\nclass Transform extends React.Component {\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            // Translation - in pixels\n            translate: {\n                x: 0,\n                y: 0\n            },\n\n            // Scale - in pixels (2 = 2x2 pixels per source pixel)\n            scale: 1,\n\n            // Rotation - in radians\n            rotate: 0,\n\n            // Whether or not we're actively transforming the children\n            active: false\n        };\n\n        this.onMouseDownCapture = this.onMouseDownCapture.bind(this);\n        this.onMouseMoveCapture = this.onMouseMoveCapture.bind(this);\n        this.onWheelCapture = this.onWheelCapture.bind(this);\n        this.onKeyDownCapture = this.onKeyDownCapture.bind(this);\n        this.onKeyUpCapture = this.onKeyUpCapture.bind(this);\n\n        this.matrix = new window.DOMMatrixReadOnly();\n    }\n\n    /**\n     * Event capture to watch for a transform toggle and prevent\n     * children from getting the same hotkey\n     */\n    onKeyDownCapture(e) {\n        if (e.keyCode === 16) { // Shift\n            this.setState({\n                active: true\n            });\n\n            e.stopPropagation();\n        }\n    }\n\n    /**\n     * Event capture to watch for a transform toggle and prevent\n     * children from getting the same hotkey\n     */\n    onKeyUpCapture(e) {\n        if (e.keyCode === 16) { // Shift\n            this.setState({\n                active: false\n            });\n\n            e.stopPropagation();\n        }\n    }\n\n    /**\n     * Event capture to ensure that children do not get mouse events\n     * while a transformation tool is active\n     */\n    onMouseDownCapture(e) {\n        if (!this.state.active) {\n            return;\n        }\n\n        // if (e.buttons === 2) {\n        //     const point = this.localSpace(\n        //         e.nativeEvent.offsetX,\n        //         e.nativeEvent.offsetY\n        //     );\n\n        //     this.rotate(\n        //         // e.nativeEvent.movementY,\n        //         0.78,\n        //         point.x,\n        //         point.y\n        //     );\n\n        //     e.stopPropagation();\n        //     return;\n        // }\n\n        e.stopPropagation();\n    }\n\n    /**\n     * Event capture to ensure that children do not get mouse events\n     * while a transformation tool is active\n     */\n    onMouseMoveCapture(e) {\n        if (!this.state.active) {\n            return;\n        }\n\n        // If dragging with Mouse 1, translate\n        if (e.buttons === 1) {\n            const invScale = 1 / this.state.scale;\n            const x = e.nativeEvent.movementX * invScale;\n            const y = e.nativeEvent.movementY * invScale;\n\n            // Apply rotations\n            // let rx = x*Math.cos(-this.state.rotate) - y*Math.sin(-this.state.rotate);\n            // let ry = x*Math.sin(-this.state.rotate) + y*Math.cos(-this.state.rotate);\n\n            this.translate(x, y);\n            e.stopPropagation();\n            return;\n        }\n    }\n\n    onWheelCapture(e) {\n        if (!this.state.active) {\n            return;\n        }\n\n        if (e.deltaY === 0 && e.deltaX === 0) {\n            return;\n        }\n\n        // Get the sign of the scroll wheel - as we don't want actual pixel-level scroll.\n        // We fallback to deltaX for mice that have inverted wheels\n        const sign = Math.sign(e.deltaY !== 0 ? e.deltaY : e.deltaX);\n        const factor = Math.pow(1.1, sign);\n\n        // Center the zoom on wherever the mouse cursor is located in local space\n        const point = this.localSpace(\n            e.nativeEvent.offsetX,\n            e.nativeEvent.offsetY\n        );\n\n        this.zoom(factor, point.x, point.y);\n\n        e.stopPropagation();\n    }\n\n    translate(x, y) {\n        this.matrix = this.matrix.translate(x, y);\n\n        this.setState({\n            translate: {\n                x: this.matrix.e,\n                y: this.matrix.f\n            }\n        });\n    }\n\n    /**\n     * Zoom to a given (x, y) in local space\n     */\n    zoom(factor, x, y) {\n        this.matrix = this.matrix.translate(x, y);\n        this.matrix = this.matrix.scale(factor, factor);\n        this.matrix = this.matrix.translate(-x, -y);\n\n        // Since zooming on a point affects translation,\n        // we extract our new translation and update that\n        // alongside our new scale\n        this.setState({\n            translate: {\n                x: this.matrix.e,\n                y: this.matrix.f\n            },\n            scale: this.state.scale * factor\n        });\n    }\n\n    /**\n     * Rotate about a point (x, y) in local space\n     */\n    rotate(rad, x, y) {\n        throw new Error('Not supported');\n    }\n\n    /**\n     * Resets this transform to the identity matrix\n     */\n    reset() {\n        this.matrix = new window.DOMMatrixReadOnly();\n\n        this.setState({\n            translate: {\n                x: 0,\n                y: 0\n            },\n            scale: 1,\n            rotate: 0\n        });\n    }\n\n    /**\n     * Convert a DOM-space point to transformation local space\n     *\n     * @param {Number} x\n     * @param {Number} y\n     */\n    localSpace(x, y) {\n        const inv = this.matrix.inverse();\n\n        return new window.DOMPoint(\n            x * inv.a + y * inv.c + inv.e,\n            x * inv.b + y * inv.d + inv.f,\n            0, 1\n        );\n    }\n\n    render() {\n        const { translate, scale, rotate } = this.state;\n\n        const children = React.Children.map(this.props.children, (child) => {\n            return React.cloneElement(child, {\n                translate,\n                scale,\n                rotate\n            });\n        });\n\n        return (\n            <div className=\"transform\"\n                onMouseDownCapture={this.onMouseDownCapture}\n                onMouseMoveCapture={this.onMouseMoveCapture}\n                onWheelCapture={this.onWheelCapture}\n                onKeyDownCapture={this.onKeyDownCapture}\n                onKeyUpCapture={this.onKeyUpCapture}\n            >\n                {children}\n            </div>\n        );\n    }\n}\n\nexport default Transform;\n","\nimport React from 'react';\nimport './Dropzone.scss';\n\n/**\n * Region that files can be dropped into for loading.\n *\n * <Dropzone onFile={callable} />\n */\nclass Dropzone extends React.Component {\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            active: false\n        }\n\n        this.onDragEnter = this.onDragEnter.bind(this);\n        this.onDragLeave = this.onDragLeave.bind(this);\n        this.onDrop = this.onDrop.bind(this);\n    }\n\n    onDragEnter(e) {\n        this.setState({\n            active: true\n        });\n\n        e.preventDefault();\n    }\n\n    onDragLeave(e) {\n        this.setState({\n            active: false\n        });\n\n        e.preventDefault();\n    }\n\n    onDrop(e) {\n        e.preventDefault();\n\n        let file;\n\n        if (e.dataTransfer.items) {\n            if (e.dataTransfer.items[0].kind === 'file') {\n                file = e.dataTransfer.items[0].getAsFile();\n            }\n        } else if (e.dataTransfer.files.length) {\n            file = e.dataTransfer.files[0];\n        }\n\n        this.setState({\n            active: false\n        });\n\n        if (file && this.props.onFile) {\n            this.props.onFile(file);\n        }\n    }\n\n    render() {\n        const { active } = this.state;\n\n        return (\n            <div className={'dropzone ' + (active ? 'is-active' : '')}\n                onDragOver={this.onDragEnter}\n                onDragEnter={this.onDragEnter}\n                onDragLeave={this.onDragLeave}\n                onDrop={this.onDrop}>\n\n                {this.props.children}\n\n                <div className=\"dropzone-overlay\">\n                    Drop files here, and other tales of help\n                </div>\n            </div>\n        );\n    }\n}\n\nDropzone.defaultProps = {\n    onFile: null\n};\n\nexport default Dropzone;\n","\nimport React from 'react';\n\n/**\n * Basic wrapper over Font Awesome (Solid)\n * \n * @param {object} props \n */\nconst Icon = (props) => {\n    const { name, ...other } = props;\n    return <i className={'fas fa-' + name} {...other}></i>\n};\n\nIcon.defaultProps = {\n    name: 'thumbs-down'\n};\n\nexport default Icon;\n","\nimport React from 'react';\n\nimport Icon from './Icon';\n\nimport './Playback.scss';\n\n/**\n * Video playback control UI:\n *  - Play/pause\n *  - Jump to start/end, Jump 1 or 5 frames either direction\n *  - Playback speed (1x, 0.5x, etc)\n *\n * <Playback\n *      playing={false} speed={1}\n *      onPause={callback}\n *      onSkip={callback(offset)}\n *      onPlay={callback}\n *      onSpeed={callback(speed)}\n * />\n *\n */\nclass Playback extends React.Component {\n    constructor(props) {\n        super(props);\n\n        this.onClickPlay = this.onClickPlay.bind(this);\n        this.onClickPause = this.onClickPause.bind(this);\n        this.onSelectSpeed = this.onSelectSpeed.bind(this);\n    }\n\n    onClickPlay() {\n        if (this.props.onPlay) {\n            this.props.onPlay();\n        }\n    }\n\n    onClickPause() {\n        if (this.props.onPause) {\n            this.props.onPause();\n        }\n    }\n\n    /**\n     * @param {SyntheticEvent} e\n     */\n    onSelectSpeed(e) {\n        if (this.props.onSpeed) {\n            this.props.onSpeed(parseFloat(e.target.value, 10));\n        }\n    }\n\n    /**\n     * Fire `onSkip` for the given offset\n     *\n     * @param {Number} offset\n     */\n    skip(offset) {\n        if (this.props.onSkip) {\n            this.props.onSkip(offset);\n        }\n    }\n\n    render() {\n        return (\n            <div className=\"playback\">\n                <div className=\"playback-speed\">\n                    <select value={this.props.speed} onChange={this.onSelectSpeed}>\n                        <option value=\"0.25\">0.25x</option>\n                        <option value=\"0.5\">0.5x</option>\n                        <option value=\"1\">1x</option>\n                        <option value=\"2\">2x</option>\n                    </select>\n                    <Icon name=\"angle-down\" />\n                </div>\n\n                <button onClick={() => this.skip(-Number.MAX_SAFE_INTEGER)}><Icon name=\"fast-backward\" /></button>\n                <button onClick={() => this.skip(-1)}><Icon name=\"step-backward\" /></button>\n                <button className=\"playback-prev-key\"><Icon name=\"step-backward\" /></button>\n\n                {!this.props.playing &&\n                    <button onClick={this.onClickPlay}><Icon name=\"play\" /></button>\n                }\n\n                {this.props.playing &&\n                    <button onClick={this.onClickPause}><Icon name=\"pause\" /></button>\n                }\n\n                {/* <button onClick={() => this.skip(5)}>+5</button>\n                <button onClick={() => this.skip(-5)}>-5</button> */}\n\n                <button className=\"playback-next-key\"><Icon name=\"step-forward\" /></button>\n                <button onClick={() => this.skip(1)}><Icon name=\"step-forward\" /></button>\n                <button onClick={() => this.skip(Number.MAX_SAFE_INTEGER)}><Icon name=\"fast-forward\" /></button>\n            </div>\n        );\n    }\n}\n\nPlayback.defaultProps = {\n    playing: false,\n    speed: 1,\n\n    onPause: null,\n    onPlay: null,\n    onSkip: null,\n    onSpeed: null\n};\n\nexport default Playback;\n","\nimport React from 'react';\n\nimport Video from './Video';\nimport RangeSlider from './RangeSlider';\nimport TimeSlider from './TimeSlider';\nimport Draw from './Draw';\nimport Transform from './Transform';\nimport Dropzone from './Dropzone';\nimport Playback from './Playback';\nimport WorkerPool from './WorkerPool';\nimport Icon from './Icon';\n\nimport './App.scss';\n\nimport Logger from './Log';\nconst log = new Logger('App');\n\nclass App extends React.Component {\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            isNewSession: true,\n\n            fps: 29.98,\n            playing: false,\n\n            loading: false,\n\n            // Video playback speed\n            speed: 1,\n\n            min: 0,\n            max: 1,\n            start: 0,\n            end: 1,\n\n            // List of key markers to send to TimeSlider.\n            // Populated with frame #'s that we draw over\n            keys: [],\n\n            // Video data\n            videoFilename: null,\n            videoSourceUrl: null,\n\n            // WorkerPool settings\n            totalWebWorkers: 0,\n\n            canvas: {\n                width: 800,\n                height: 600\n            }\n        };\n\n        // Cache of serialized Draw content per-frame.\n        // Eventually, this will be some localStorage object.\n        this.drawCache = {};\n\n        this.video = React.createRef();\n        this.workers = React.createRef();\n        this.time = React.createRef();\n        this.range = React.createRef();\n        this.draw = React.createRef();\n        this.canvas = React.createRef();\n\n        // Events for <Video>\n        this.onVideoReady = this.onVideoReady.bind(this);\n        this.onFrame = this.onFrame.bind(this);\n\n        // Events for <RangeSlider>\n        this.onPickRange = this.onPickRange.bind(this);\n\n        // Events for <TimeSlider>\n        this.onPickFrame = this.onPickFrame.bind(this);\n\n        // Events for <Dropzone>\n        this.onDropFile = this.onDropFile.bind(this);\n\n        // Events for <Playback>\n        this.onPlaybackSpeed = this.onPlaybackSpeed.bind(this);\n        this.onPlaybackPlay = this.onPlaybackPlay.bind(this);\n        this.onPlaybackPause = this.onPlaybackPause.bind(this);\n        this.onPlaybackSkip = this.onPlaybackSkip.bind(this);\n\n        // Events for <Draw>\n        this.onDrawDraw = this.onDrawDraw.bind(this);\n        this.onDrawClear = this.onDrawClear.bind(this);\n\n        // Events for <WorkerPool>\n        this.onWorkerMetadata = this.onWorkerMetadata.bind(this);\n        this.onWorkerFrames = this.onWorkerFrames.bind(this);\n\n        this.onAddWebWorker = this.onAddWebWorker.bind(this);\n\n        // Experimental placeholder\n        this.onFrameCache = this.onFrameCache.bind(this);\n    }\n\n    componentDidMount() {\n        this.updateCanvasDimensions();\n    }\n\n    /**\n     * Update calculated dimensions of the canvas region\n     * \n     * Called on initialization and window resize events\n     */\n    updateCanvasDimensions() {\n        this.setState({\n            canvas: {\n                width: this.canvas.current.clientWidth,\n                height: this.canvas.current.clientHeight\n            }\n        });\n    }\n\n    /**\n     * Event handler for when the Video component has loaded content\n     *\n     * This will update TimeSlider and RangeSlider with appropriate playback ranges\n     */\n    onVideoReady() {\n        this.setState({\n            min: 0,\n            max: this.video.current.totalFrames,\n            start: 0,\n            end: this.video.current.totalFrames\n        });\n    }\n\n    /**\n     * Callback for when WorkerPool extracts a range of frames\n     *\n     * @param {Number} start frame\n     * @param {Number} end frame\n     * @param {array} frames Frame data\n     */\n    onWorkerFrames(start, end, frames) {\n        log.info('onWorkerFrames', start, end);\n\n        this.video.current.cacheFrames(start, end, frames);\n\n        // Also update the time slider to indicate which frames\n        // have a cache loaded (warning: probably slow AF)\n        const len = Math.min(frames.length, end - start);\n        for (let i = 0; i < len; i++) {\n            if (!this.time.current.hasKey(start + i)) {\n                this.time.current.setKey(start + i, 'cached-frame');\n            }\n        }\n    }\n\n    /**\n     * Callback for when WorkerPool extracts additional video metadata\n     */\n    onWorkerMetadata(metadata) {\n        log.info(metadata);\n\n        // Now that we have video data, we're ready to start editing\n        this.setState({\n            fps: metadata.fps,\n            loading: false\n        });\n    }\n\n    /**\n     * Event handler for when Video changes rendered frame\n     *\n     * @param {integer} frame\n     */\n    onFrame(frame) {\n        if (!this.video.current) {\n            return;\n        }\n\n        if (this.frame !== frame) {\n            this.changeDrawover(this.frame, frame);\n            this.time.current.setFrame(frame);\n\n            this.frame = frame;\n        }\n    }\n\n    onFrameCache(frame) {\n        this.time.current.setKey(frame, 'cached-frame');\n    }\n\n    /**\n     * Event handler for when the range slider changes active range.\n     *\n     * Update our time slider with the new range and clamp video playback\n     */\n    onPickRange(start, end) {\n        this.time.current.setRange(start, end);\n        this.video.current.startFrame = start;\n        this.video.current.endFrame = end;\n    }\n\n    /**\n     * Event handler for when the time slider is manually set to a frame\n     *\n     * This will pause video playback and jump it to the desired frame\n     */\n    onPickFrame(frame) {\n        this.video.current.pause();\n        this.video.current.frame = frame;\n\n        if (frame !== this.frame) {\n            this.changeDrawover(this.frame, frame);\n            this.frame = frame;\n        }\n    }\n\n    /**\n     * Update playback speed of the video\n     */\n    onPlaybackSpeed(value) {\n        this.setState({\n            speed: value\n        });\n\n        this.video.current.speed = value;\n    }\n\n    /**\n     * Event handler to start video playback\n     */\n    onPlaybackPlay() {\n        this.video.current.play();\n\n        // TODO: Probably only set once the\n        // video source confirms it's playing.\n        this.setState({ playing: true });\n    }\n\n    /**\n     * Event handler to pause video playback\n     */\n    onPlaybackPause() {\n        this.video.current.pause();\n\n        // TODO: Probably only set once the\n        // video source confirms it's playing.\n        this.setState({ playing: false });\n    }\n\n    /**\n     * Skip the video forward/back the specified number of frames\n     *\n     * Frame skip is clamped to the range defined by RangeSlider\n     *\n     * @param {Number} frames to skip forward/back\n     */\n    onPlaybackSkip(frames) {\n        this.video.current.skip(frames);\n    }\n\n    /**\n     * Local file from disk was dropped into our Dropzone\n     *\n     * If it's a video file, load it to replace the existing video.\n     * If it's some other persisted file, load that instead.\n     */\n    onDropFile(file) {\n        log.info(file);\n\n        if (this.video.current.canLoad(file)) {\n            this.changeVideoSource(file);\n        } else {\n            alert('Cannot load type: ' + file.type);\n        }\n\n        // TODO: Check for other types of files and ways to handle them\n    }\n\n    /**\n     * Draw layer had a new brush update added\n     */\n    onDrawDraw() {\n        const frame = this.video.current.frame;\n        log.info('Draw Update', frame);\n\n        // Placeholder the drawCache - we won't serialize until\n        // we swap off of this frame.\n        this.drawCache[frame] = null;\n\n        // Add a key to TimeSlider immediately to let the\n        // user know that their line created a new key frame\n        this.time.current.setKey(frame, 'draw-frame');\n\n        // Start caching frames around this frame (5 seconds both directions)\n        this.workers.current.extractFrames(frame, 5 * this.state.fps);\n    }\n\n    /**\n     * Draw layer is cleared of content, either by\n     * a clear button, or history undo\n     */\n    onDrawClear() {\n        const video = this.video.current;\n        const time = this.time.current;\n        const frame = video.frame;\n\n        log.info('Draw Clear', frame);\n\n        // Remove the empty frame from our cache\n        delete this.drawCache[frame];\n\n        // Reset to prior key color\n        if (video.isFrameCached(frame)) {\n            time.setKey(frame, 'cached-frame');\n        } else {\n            time.deleteKey(frame);\n        }\n    }\n\n    /**\n     * Click callback to add more workers to WorkerPool\n     */\n    onAddWebWorker() {\n        this.setState({\n            totalWebWorkers: this.state.totalWebWorkers + 1\n        });\n    }\n\n    /**\n     * Swap Draw content to match the given frame\n     *\n     * This will serialize and store the current state of the Draw\n     * Draw component to the previous frame, and either start a new\n     * empty canvas for the specified frame or load the previously\n     * serialized content back into Draw.\n     *\n     * @param {Number} prevFrame to cache current Draw content\n     * @param {Number} frame to display new Draw content\n     */\n    changeDrawover(prevFrame, frame) {\n        const draw = this.draw.current;\n        const time = this.time.current;\n        const video = this.video.current;\n\n        // If there's content, key it and cache the Draw content\n        if (!draw.isEmpty()) {\n            time.setKey(prevFrame, 'draw-frame');\n            this.drawCache[prevFrame] = draw.serialize();\n        } else {\n            // Canvas is empty - make sure we didn't still have anything\n            // cached or keyed to indicate that there is draw content.\n            delete this.drawCache[prevFrame];\n\n            // Reset to prior key color\n            if (video.isFrameCached(prevFrame)) {\n                time.setKey(prevFrame, 'cached-frame');\n            } else {\n                time.deleteKey(prevFrame);\n            }\n        }\n\n        draw.reset();\n\n        // Try to load current Draw content from the cache\n        if (frame in this.drawCache) {\n            draw.deserialize(this.drawCache[frame]);\n        }\n\n        // Update ghost <Draw> components\n        this.updateGhosting();\n    }\n\n    /**\n     * Load a new file as our video source.\n     *\n     * This will clear everything (timeline, keys, etc) and start\n     * fresh with the new video\n     */\n    changeVideoSource(file) {\n        let url = file;\n        let filename = file;\n\n        if (file instanceof File) {\n            url = URL.createObjectURL(file);\n            filename = file.name;\n        }\n\n        this.setState({\n            loading: true,\n            isNewSession: false,\n\n            frame: 0,\n            playing: false,\n            speed: 1,\n            min: 0,\n            max: 1,\n            start: 0,\n            end: 1,\n            keys: [],\n\n            videoFilename: filename,\n            videoSourceUrl: url\n        });\n\n        this.time.current.deleteAllKeys();\n\n        // Will trigger a new onVideoReady call on success\n        // and update the state range\n        this.video.current.load(url);\n\n        // Clear caches\n        this.draw.current.reset();\n        this.drawCache = {};\n\n        if (file instanceof File) {\n            this.workers.current.load(file);\n        } else {\n            log.warning('Skipping WorkerPool load for non-local source file');\n        }\n    }\n\n    /**\n     * Get the previous frame that has a Draw cached prior to `frame`\n     *\n     * @param {Number} frame\n     *\n     * @return {Number|false}\n     */\n    getPreviousDrawFrame(frame) {\n        let frames = Object.keys(this.drawCache);\n        let i;\n\n        for (i = frames.length - 1; i >= 0; i--) {\n            if (frames[i] < frame) {\n                break;\n            }\n        }\n\n        // If we went before the list start, no frames match\n        if (i < 0) {\n            return false;\n        }\n\n        // Return the frame we broke on\n        return parseInt(frames[i], 10);\n    }\n\n    /**\n     * Get the next frame that has a Draw cached after `frame`\n     *\n     * @param {Number} frame\n     *\n     * @return {Number|false}\n     */\n    getNextDrawFrame(frame) {\n        let frames = Object.keys(this.drawCache);\n        let i;\n\n        for (i = 0; i < frames.length; i++) {\n            if (frames[i] > frame) {\n                break;\n            }\n        }\n\n        // If i is list end, no eligible frames after `frame`\n        if (i === frames.length) {\n            return false;\n        }\n\n        // Return the frame we broke on\n        return parseInt(frames[i], 10);\n    }\n\n    /**\n     * Change the rendered content for previous ghost frames\n     *\n     * Ghosting will render `props.ghostLayers` previous draw frames\n     * under the current frame - each with decrementing alpha values\n     */\n    updateGhosting() {\n        const frame = this.video.current.frame;\n        let i;\n\n        let adjacent = this.getPreviousDrawFrame(frame);\n        for (i = 0; i < this.props.ghostLayers; i++) {\n            if (adjacent !== false) {\n                this.refs['ghostBack' + i].deserialize(this.drawCache[adjacent]);\n                adjacent = this.getPreviousDrawFrame(adjacent);\n            } else {\n                this.refs['ghostBack' + i].clear();\n            }\n        }\n\n        // adjacent = this.getNextDrawFrame(frame);\n        // for (i = 0; i < this.props.ghostLayers && adjacent !== false; i++) {\n        //     this.refs['ghostForward' + i].deserialize(this.drawCache[adjacent]);\n        //     adjacent = this.getNextDrawFrame(adjacent);\n        // }\n    }\n\n    /**\n     * Return a set of <Draw> components\n     *\n     * This will return an active Draw component with event\n     * hooks to all of our interactivity with the current frame,\n     * as well as other readonly draw frames for ghosting /\n     * onion skinning our previous and next frames.\n     */\n    renderDrawovers() {\n        const components = [];\n        let opacity;\n\n        // We add the lowest (furthest) layers first\n        for (let i = this.props.ghostLayers - 1; i >= 0; i--) {\n            opacity = 1 - (i + 1) * this.props.ghostOpacityScale;\n\n            components.push(\n                <Draw key={'ghostBack' + i}\n                    ref={'ghostBack' + i}\n                    readonly={true}\n                    opacity={opacity}\n                    width={this.state.canvas.width} \n                    height={this.state.canvas.height}\n                />\n            );\n\n            // components.push(\n            //     <Draw ref={'ghostForward' + i}\n            //         width=\"720\" height=\"480\"\n            //         readonly={true}\n            //         opacity={opacity}\n            //     />\n            // );\n        }\n\n        components.push(\n            <Draw key={'main'} ref={this.draw}\n                onDraw={this.onDrawDraw}\n                onClear={this.onDrawClear}\n                width={this.state.canvas.width} \n                height={this.state.canvas.height}\n            />\n        );\n\n        return components;\n    }\n\n    render() {\n        return (\n            <div className=\"app\">\n                {/* {this.state.loading &&\n                    <div className=\"app-loader\">\n                        Loading source video\n                    </div>\n                } */}\n\n                <div className=\"app-canvas\" ref={this.canvas}>\n                    {this.state.isNewSession && \n                        <div className=\"app-new-session\">\n                            <p>Drop an MP4 or WebM to get started</p>\n                            <Icon name=\"film\" />\n                        </div>\n                    }         \n\n                    <Dropzone onFile={this.onDropFile}>\n                        <Transform>\n                            <Video ref={this.video}\n                                fps={this.state.fps}\n                                onReady={this.onVideoReady}\n                                onFrame={this.onFrame}\n                                onFrameCache={this.onFrameCache}\n                                width={this.state.canvas.width} \n                                height={this.state.canvas.height}\n                            />\n\n                            {this.renderDrawovers()}\n                        </Transform>\n                    </Dropzone>\n                </div>\n\n                <div className=\"app-controls\">\n                    <div className=\"app-controls-row\">\n                        <TimeSlider ref={this.time}\n                            fps={this.state.fps}\n                            onChange={this.onPickFrame} />\n\n                        <Playback\n                            playing={this.state.playing}\n                            speed={this.state.speed}\n                            onPause={this.onPlaybackPause}\n                            onSkip={this.onPlaybackSkip}\n                            onPlay={this.onPlaybackPlay}\n                            onSpeed={this.onPlaybackSpeed}\n                        />\n                    </div>\n\n                    <div className=\"app-controls-row\">\n                        <RangeSlider ref={this.range}\n                            fps={this.state.fps}\n                            min={this.state.min}\n                            max={this.state.max}\n                            onChange={this.onPickRange} />\n                    </div>\n\n                    <WorkerPool ref={this.workers}\n                        workers={this.state.totalWebWorkers}\n                        onMetadata={this.onWorkerMetadata}\n                        onFrames={this.onWorkerFrames} />\n                        \n                    {/* <button onClick={this.onAddWebWorker}>Add Web Worker</button> */}\n                </div>\n            </div>\n        );\n    }\n}\n\nApp.defaultProps = {\n    // How many drawn frame forward/behind the current\n    // frame should be rendered at once\n    ghostLayers: 3,\n\n    // How much to decrement opacity per ghost layer\n    ghostOpacityScale: 0.3\n};\n\nexport default App;\n","\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport registerServiceWorker from './registerServiceWorker';\n\nimport App from './App';\n\n// Activate the debug library on non-production using a key in localStorage\nif (process.env.NODE_ENV !== 'production') {\n    localStorage.setItem('debug', 'drawover:*');\n}\n\nReactDOM.render(<App/>, document.getElementById('root'));\n\nregisterServiceWorker();\n"],"sourceRoot":""}